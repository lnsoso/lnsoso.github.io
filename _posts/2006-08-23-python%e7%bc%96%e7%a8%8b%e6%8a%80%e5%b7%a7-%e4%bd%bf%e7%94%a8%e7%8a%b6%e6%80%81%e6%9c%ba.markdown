---
layout: post
title: Python编程技巧 - 使用状态机
author: gavinkwoe
date: !binary |-
  MjAwNi0wOC0yMyAxMToxNjowOCArMDgwMA==
date_gmt: !binary |-
  MjAwNi0wOC0yMyAwMzoxNjowOCArMDgwMA==
---
状态机从理论上说是几乎与计算机和编程相关的每件事的基础。从实用角度来看，状态机还有助于解决许多常见问题（特别适用于 Python 程序员）。本文中，David Mertz 讨论了何时以及如何使用 Python 编码状态机的实际例子。
    <strong>什么是 Python？</strong>
    Python 是由 Guido van Rossum 开发的免费高级解释型语言。其语法简单易懂，而其面向对象的语义功能强大（但又灵活）。Python 可以广泛使用并具有高度的可移植性。
<strong>    什么是状态机？</strong>
    关于状态机的一个极度确切的描述是它是一个有向图形，由一组节点和一组相应的转移函数组成。状态机通过响应一系列事件而“运行”。每个事件都在属于“当前”节点的转移函数的控制范围内，其中函数的范围是节点的一个子集。函数返回“下一个”（也许是同一个）节点。这些节点中至少有一个必须是终态。当到达终态，状态机停止。
    但一个抽象的数学描述（就像我刚给出的）并不能真正说明在什么情况下使用状态机可以解决实际编程问题。另一种策略就是将状态机定义成一种强制性编程语言，其中节点也是源码行。从实用角度看，这个定义尽管精确，但它和第一种描述一样，都是纸上谈兵、毫不实用。（对于说明型、函数型或基于约束的语言，例如，Haskell、Scheme 或 Prolog，不一定会发生这种情况。）
    让我们尝试使用更适合身边实际任务的例子来进行讨论。逻辑上，每个规则表达式都等价于一个状态机，而每个规则表达式的语法分析器都实现这个状态机。实际上，大多数程序员编写状态机时，并没有真正考虑到这一点。
    在以下这个例子中，我们将研究状态机的真正探索性定义。通常，我们有一些不同的方法来响应一组有限数量的事件。某些情况下，响应只取决于事件本身。但在其它情况下，适当的操作取决于以前的事件。
    本文中讨论的状态机是高级机器，其目的是演示一类问题的编程解决方案。如果有必要按响应事件行为的类别来讨论编程问题，那么您的解决方案很可能是显式状态机。
<span class="atitle"><font size="2" face="Arial"><strong>   文本处理状态机</strong></font></span>
最可能调用显式状态机的一个编程问题涉及到处理文本文件。处理文本文件通常包括读取信息单元（通常叫做字符或行），然后对刚读取的单元执行适当操作。某些情况下，这个处理是“无状态的”（即每个这样的单元都包含了足够的信息，可以正确确定要执行什么操作）。在其它情况下，即使文本文件不是完全无状态，数据也只有有限的上下文（例如，操作取决于不比行号更多的信息）。但是，在其它常见文本处理问题中，输入文件是极具“状态”的。每一块数据的含义取决于它前面的字符串（也许是它后面的字符串）。报告、大型机数据输入、可读文本、编程源文件和其它种类的文本文件都是有状态的。一个简单例子是可能出现在 Python 源文件中的一行代码：
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><font face="Lucida Console">myObject = SomeClass(this, that, other)      </font></code></pre>
</td>
</tr>
</table>
这行表示，如果恰好有以下几行围绕着这一行，则有部分内容不同：
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><font face="Lucida Console">"""How to use SomeClass:myObject = SomeClass(this, that, other)"""      </font></code></pre>
</td>
</tr>
</table>
我们应知道我们处于“块引用” <strong>状态</strong> 以确定这行代码是一部分注释而不是 Python 操作。
<span class="atitle"><font size="4" face="Arial">何时不使用状态机</font></span>
当开始为任何有状态的文本文件编写处理器的任务时，问一问自己，您希望在文件中找到什么类型的输入项。每种类型的输入项都是一种状态的候选项。这些类型共有几种。如果数字很大或者不确定，则状态机也许不是正确的解决方法。（在这种情况下，某些数据库解决方案可能更适合。）
还请考虑您是否需要使用状态机。许多情况下，最好从更简单的方法入手。也许会发现即使文本文件是有状态的，也有一种简单的方法可以分块读取它（其中每一块是一种类型的输入值）。实际上，在单一状态块中，仅当文本类型之间的转移需要基于内容的计算时，才有必要实现状态机。
下面这个简单的例子说明了需要使用状态机的情况。请考虑用于将一列数字划分成几块的两个规则。在第一个规则中，列表中的零表示块之间的间断。第二个规则中，当一个块中的元素总和超过 100 时，会发生块之间的间断。由于它使用累加器变量来确定是否达到了阈值，您不能“马上”看到子列表的边界。因此，第二个规则也许更适合于类似于状态机的机制。
稍微有些状态、但由 <em>不</em> 太适合用状态机处理的文本文件的例子是 Windows 风格的 .ini 文件。这种文件包括节头、注释和许多赋值。例如：
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><font face="Lucida Console">; set the colorscheme and userlevel[colorscheme]background=redforeground=bluetitle=green[userlevel]login=2title=1      </font></code></pre>
</td>
</tr>
</table>
我们的例子没有实际含义，但它表明了 .ini 格式一些有趣的特性。
<ul>
<li>就某种意义而言，每一行的类型由它的第一个字符确定（可能是分号、左花括号或字母）。</li>
<li>从另一种角度看，这种格式是“有状态的”，因为关键字 "title" 大概表示如果它出现在每一节中，那么就有独立的内容。</li>
</ul>
您可以编写一个有 COLORSCHEME 状态和 USERLEVEL 状态的文本处理器程序，这个程序仍处理每个状态的赋值。但这好象不是处理此问题的 <em>正确</em> 方法。例如，可以使用 Python 代码在这个文本文件中只创建自然块，如：
<strong>处理 .INI 文件的分块 Python 代码</strong>
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><font face="Lucida Console">stringtxt = open( 'hypothetical.ini').read()</font></code><code class="section"><font face="Lucida Console">sects = string.split(txt,'[')</font><span class="boldcode"><strong><font face="Lucida Console">for </font></strong></span><font face="Lucida Console">sect </font><span class="boldcode"><strong><font face="Lucida Console">in </font></strong></span><font face="Lucida Console">sects:    # do something with sect, like get its name    # (the stuff up to ']') and read its assignments               </font></code></pre>
</td>
</tr>
</table>
或者，如果愿意，可以使用单个 <code><font face="新宋体">current_section</font></code> 变量来确定位置：
<strong>处理 .INI 文件的计算 Python 代码</strong>
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><span class="boldcode"><strong><font face="Lucida Console">for </font></strong></span><font face="Lucida Console">line </font><span class="boldcode"><strong><font face="Lucida Console">in </font></strong></span><font face="Lucida Console">open('hypothetical.ini').readlines():</font><span class="boldcode"><strong><font face="Lucida Console">    if </font></strong></span><font face="Lucida Console">line[0] == '[': current_section = line(1:-2)     </font><span class="boldcode"><strong><font face="Lucida Console">elif </font></strong></span><font face="Lucida Console">line[0] == ';':</font><span class="boldcode"><strong><font face="Lucida Console">        pass </font></strong></span><font face="Lucida Console"># ignore comments            </font><span class="boldcode"><strong><font face="Lucida Console">    else</font></strong></span><font face="Lucida Console">:         apply_value(current_section, line)            </font></code></pre>
</td>
</tr>
</table>
<span class="atitle"><font size="4" face="Arial">何时使用状态机</font></span>
现在，我们已经决定了如果文本文件“太简单”就不使用状态机，让我们再研究 <em>需要</em>使用状态机的情况。本专栏中 最近一篇文章 讨论了实用程序 Txt2Html，它将“智能 ASCII”（包括本文）转换成 HTML。让我们扼要重述。
“智能 ASCII”是一种文本格式，它使用一些间隔约定来区分文本块的类型，如头、常规文本、引语和代码样本。虽然读者或作者能容易地通过查看分析这些文本块类型之间的转移，但却没有简单的方法可以让计算机将“智能 ASCII”文件分割成组成它的文本块。不像 .ini 文件示例，文本块类型可以任何顺序出现。在任何情况下都没有单一定界符来分隔块（空行 <em>通常</em> 分隔文本块，但代码样本中的空行却不一定结束代码样本，并且文本块不需要用空行来分隔）。由于需要以不同方式重新格式化每个文本块以生成正确的 HTML 输出，状态机似乎就是自然的解决方案。
Txt2Html 阅读器的一般功能如下：
<ol>
<li>在初始状态中启动。</li>
<li>读取一行输入。</li>
<li>根据输入和当前状态，转移到新状态或按适合当前状态的方式处理该行。</li>
</ol>
这个例子是关于您会遇到的最简单的情况，但它说明了我们描述过的以下模式：
<strong>Python 中一个简单的状态机输入循环</strong><br clear="all" />
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><span class="boldcode"><strong><font face="Lucida Console">global </font></strong></span><font face="Lucida Console">state, blocks, bl_num, newblock#-- Initialize the globalsstate = "HEADER"blocks = [""]bl_num = 0newblock = 1</font><span class="boldcode"><strong><font face="Lucida Console">for </font></strong></span><font face="Lucida Console">line </font><span class="boldcode"><strong><font face="Lucida Console">in </font></strong></span><font face="Lucida Console">fhin.readlines():</font><span class="boldcode"><strong><font face="Lucida Console">    if </font></strong></span><font face="Lucida Console">state == "HEADER":        # blank line means new block of header</font><span class="boldcode"><strong><font face="Lucida Console">       if </font></strong></span><font face="Lucida Console">blankln.match(line): newblock = 1</font><span class="boldcode"><strong><font face="Lucida Console">       elif </font></strong></span><font face="Lucida Console">textln.match(line): startText(line)</font></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">       elif </font></strong></span><font face="Lucida Console">codeln.match(line): startCode(line)</font><span class="boldcode"><strong><font face="Lucida Console">       else </font></strong></span><font face="Lucida Console">:</font><span class="boldcode"><strong><font face="Lucida Console">           if </font></strong></span><font face="Lucida Console">newblock: startHead(line)</font><span class="boldcode"><strong><font face="Lucida Console">           else </font></strong></span><font face="Lucida Console">: blocks[bl_num] = blocks[bl_num] + line</font><span class="boldcode"><strong><font face="Lucida Console">           elif </font></strong></span><font face="Lucida Console">state == "TEXT":                 # blank line means new block of text</font><span class="boldcode"><strong><font face="Lucida Console">               if </font></strong></span><font face="Lucida Console">blankln.match(line): newblock = 1</font></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">               elif </font></strong></span><font face="Lucida Console">headln.match(line): startHead(line)</font></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">               elif </font></strong></span><font face="Lucida Console">codeln.match(line): startCode(line)</font><span class="boldcode"><strong><font face="Lucida Console">               else </font></strong></span><font face="Lucida Console">:     </font><span class="boldcode"><strong><font face="Lucida Console">               if </font></strong></span><font face="Lucida Console">newblock: startText(line)     </font><span class="boldcode"><strong><font face="Lucida Console">               else </font></strong></span><font face="Lucida Console">: blocks[bl_num] = blocks[bl_num] + line     </font><span class="boldcode"><strong><font face="Lucida Console">               elif </font></strong></span><font face="Lucida Console">state == "CODE":                          # blank line does not change state      </font><span class="boldcode"><strong><font face="Lucida Console">                  if </font></strong></span><font face="Lucida Console">blankln.match(line): blocks[bl_num] = blocks[bl_num] + line         </font><span class="boldcode"><strong><font face="Lucida Console">               elif </font></strong></span><font face="Lucida Console">headln.match(line): startHead(line)         </font><span class="boldcode"><strong><font face="Lucida Console">               elif </font></strong></span><font face="Lucida Console">textln.match(line): startText(line) </font></code><code class="section"><font face="Lucida Console">        </font><span class="boldcode"><strong><font face="Lucida Console">               else </font></strong></span><font face="Lucida Console">: blocks[bl_num] = blocks[bl_num] + line         </font><span class="boldcode"><strong><font face="Lucida Console">               else </font></strong></span><font face="Lucida Console">:        </font><span class="boldcode"><strong><font face="Lucida Console">                     raise </font></strong></span><font face="Lucida Console">ValueError, "unexpected input block state: "+state            </font></code></pre>
</td>
</tr>
</table>
可以用 Txt2Html 下载从中取出该代码的源文件（请参阅 参考资料 ）。请注意：变量 <code><font face="新宋体">state</font></code> 声明为 <code><font face="新宋体">global</font></code> ，在函数（如 <code><font face="新宋体">startText()</font></code> ）中更改它的值。转移条件，如 <code><font face="新宋体">textln.match()</font></code> ，是规则表达式模式，但它们可能也是定制函数。实际上，以后会在程序中执行格式化。状态机只将文本文件分析成 <code><font face="新宋体">blocks</font></code> 列表中带标签的块。
<span class="atitle"><font size="4" face="Arial">抽象状态机类</font></span>
在表单和函数中使用 Python 实现抽象状态机很容易。这使程序的状态机模型比前一个例子中的简单条件块显得更突出（初看，其中的条件与其它条件没有什么不同）。而且，以下类及其关联处理程序在隔离状态中操作方面完成得很好。许多情况下，这改善了封装和可读性。
<strong>文件：statemachine.py</strong><br clear="all" />
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><span class="boldcode"><strong><font face="Lucida Console">from </font></strong></span><font face="Lucida Console">string </font><span class="boldcode"><strong><font face="Lucida Console">import </font></strong></span><font face="Lucida Console">upper</font><span class="boldcode"><strong><font face="Lucida Console">class </font></strong><strong><font face="Lucida Console">StateMachine </font></strong></span><font face="Lucida Console">:    </font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">__init__</font></strong></span><font face="Lucida Console">(self):        self.handlers = {}        self.startState = None       </font></code><code class="section"><font face="Lucida Console"> self.endStates = []    </font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">add_state</font></strong></span><font face="Lucida Console">(self, name, handler, end_state=0):        name = upper(name)       </font></code><code class="section"><font face="Lucida Console"> self.handlers[name] = handler</font><span class="boldcode"><strong><font face="Lucida Console">       if </font></strong></span><font face="Lucida Console">end_state: self.endStates.append(name)</font></code><code class="section"><font face="Lucida Console">    </font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">set_start</font></strong></span><font face="Lucida Console">(self, name):        self.startState = upper(name)    </font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">run</font></strong></span><font face="Lucida Console">(self, cargo):        </font><span class="boldcode"><strong><font face="Lucida Console">try </font></strong></span><font face="Lucida Console">: handler = self.handlers[self.startState]        </font><span class="boldcode"><strong><font face="Lucida Console">except </font></strong></span><font face="Lucida Console">:             </font><span class="boldcode"><strong><font face="Lucida Console">raise </font></strong></span><font face="Lucida Console">"InitializationError", "must call .set_start() before .run()"</font><span class="boldcode"><strong><font face="Lucida Console">       if </font></strong></span><span class="boldcode"><strong><font face="Lucida Console">not </font></strong></span><font face="Lucida Console">self.endStates:</font><span class="boldcode"><strong><font face="Lucida Console">          raise </font></strong></span><font face="Lucida Console">"InitializationError", "at least one state must be an end_state"    </font><span class="boldcode"><strong><font face="Lucida Console">    while </font></strong></span><font face="Lucida Console">1: (newState, cargo) = handler(cargo)</font><span class="boldcode"><strong><font face="Lucida Console">          if </font></strong></span><font face="Lucida Console">upper(newState)</font><span class="boldcode"><strong><font face="Lucida Console"> in </font></strong></span><font face="Lucida Console">self.endStates:</font><span class="boldcode"><strong><font face="Lucida Console"> break</font></strong></span><span class="boldcode"><strong><font face="Lucida Console">          else </font></strong></span><font face="Lucida Console">: handler = self.handlers[upper(newState)]            </font></code></pre>
</td>
</tr>
</table>
<code><font face="新宋体">   StateMachine</font></code> 类实际上正是抽象状态机所需要的。因为使用 Python 传递函数对象是如此简单，与其它语言中的相似类比较，这个类所需使用行数非常少。
   要真正 <em>使用</em> <code><font face="新宋体">StateMachine</font></code> 类，需要为每个要使用的状态创建一些处理程序。处理程序必须符合模式。它循环处理事件，直到要转移到另一个状态，此时处理程序应该将一个字节组（它包括新状态名称以及新的状态处理程序需要的任何 cargo）传递回去。
   在 <code><font face="新宋体">StateMachine</font></code> 类中将 <code><font face="新宋体">cargo</font></code> 用作变量的做法将封装状态处理程序所需的数据（该状态处理程序不必调用它的 <code><font face="新宋体">cargo</font></code> 变量）。状态处理程序使用 <code><font face="新宋体">cargo</font></code> 来传递下一个处理程序所需的内容，于是新的处理程序可以接管前一个处理程序的遗留工作。 <code><font face="新宋体">cargo</font></code> 通常包括文件句柄，它允许下一个处理程序可以在前一个处理程序停止后读取更多数据。 <code><font face="新宋体">cargo</font></code> 还可能是数据库连接、复杂的类实例或带有几个项的列表。
   现在，让我们研究测试样本。在本例中（在以下代码示例中概述），cargo 只是不断将反馈传送给迭代函数的一个数字。只要 <code><font face="新宋体">val</font></code> 处于某个范围内，则 <code><font face="新宋体">val</font></code> 的下一个值永远只是 <code><font face="新宋体">math_func(val)</font></code> 。一旦函数返回了超出范围的值，那么该值将传送到另一个处理程序，或者状态机在调用了一个什么也不做的终态处理程序后就退出。示例说明了一件事： <em>事件</em>不必是输入事件。它也可以是计算事件（这种情况很少）。状态处理程序相互之间的区别只是在输出它们处理的事件时使用不同的标记。该函数比较简单，没必要使用状态机。但它很好地说明了概念。代码也许比解释更易于理解！
 <strong>文件：statemachine_test.py<br clear="all" /></strong>
<table border="1" bgColor="#eeeeee" width="100%" cellPadding="5" cellSpacing="0">
<tr>
<td>
<pre><code class="section"><span class="boldcode"><strong><font face="Lucida Console">from </font></strong></span><font face="Lucida Console">statemachine </font><span class="boldcode"><strong><font face="Lucida Console">import </font></strong></span><font face="Lucida Console">StateMachine</font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">ones_counter</font></strong></span><font face="Lucida Console">(val):    </font><span class="boldcode"><strong><font face="Lucida Console">print </font></strong></span><font face="Lucida Console">"ONES State: ",    </font><span class="boldcode"><strong><font face="Lucida Console">while </font></strong></span><font face="Lucida Console">1:        </font><span class="boldcode"><strong><font face="Lucida Console">if </font></strong></span><font face="Lucida Console">val <= 0 </font><span class="boldcode"><strong><font face="Lucida Console">or </font></strong></span><font face="Lucida Console">val >= 30:            newState = "Out_of_Range";            </font><span class="boldcode"><strong><font face="Lucida Console">break       elif</font></strong></span><font face="Lucida Console"> 20 <= val < 30:            newState = "TWENTIES";</font><span class="boldcode"><strong><font face="Lucida Console">          break       elif </font></strong></span><font face="Lucida Console">10 <= val < 20:            newState = "TENS";</font><span class="boldcode"><strong><font face="Lucida Console">          break       else </font></strong></span><font face="Lucida Console">:</font><span class="boldcode"><strong><font face="Lucida Console">          print </font></strong></span><font face="Lucida Console">" @ %2.1f+" % val, val = math_func(val)</font><span class="boldcode"><strong><font face="Lucida Console">          print </font></strong></span><font face="Lucida Console">" >>"    </font><span class="boldcode"><strong><font face="Lucida Console">return </font></strong></span><font face="Lucida Console">(newState, val)</font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">tens_counter </font></strong></span><font face="Lucida Console">(val):    </font><span class="boldcode"><strong><font face="Lucida Console">print </font></strong></span><font face="Lucida Console">"TENS State: ",    </font><span class="boldcode"><strong><font face="Lucida Console">while 1</font></strong></span><font face="Lucida Console">:        </font><span class="boldcode"><strong><font face="Lucida Console">if </font></strong></span><font face="Lucida Console">val <= 0 </font><span class="boldcode"><strong><font face="Lucida Console">or </font></strong></span><font face="Lucida Console">val >= 30: newState =  "Out_of_Range"; </font><span class="boldcode"><strong><font face="Lucida Console">break       elif </font></strong></span><font face="Lucida Console">1 <= val < 10: newState = "ONES";</font><span class="boldcode"><strong><font face="Lucida Console"> break       elif </font></strong></span><font face="Lucida Console">20 <= val < 30: newState = "TWENTIES"; </font><span class="boldcode"><strong><font face="Lucida Console">break     </font></strong></span></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">  else </font></strong></span><font face="Lucida Console">:               </font><span class="boldcode"><strong><font face="Lucida Console">print </font></strong></span><font face="Lucida Console">" #%2.1f+" % val, val = math_func(val)</font></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">            print </font></strong></span><font face="Lucida Console">" >>"</font><span class="boldcode"><strong><font face="Lucida Console">    return</font></strong></span><font face="Lucida Console">(newState, val)</font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">twenties_counter</font></strong></span><font face="Lucida Console">(val):</font><span class="boldcode"><strong><font face="Lucida Console">    print </font></strong></span><font face="Lucida Console">"TWENTIES State:",</font><span class="boldcode"><strong><font face="Lucida Console">    while </font></strong></span><font face="Lucida Console">1:        </font><span class="boldcode"><strong><font face="Lucida Console">if </font></strong></span><font face="Lucida Console">val <= 0 </font><span class="boldcode"><strong><font face="Lucida Console">or </font></strong></span><font face="Lucida Console">val >= 30: newState = "Out_of_Range"; </font><span class="boldcode"><strong><font face="Lucida Console">break       elif </font></strong></span><font face="Lucida Console">1 <= val < 10: newState = "ONES"; </font><span class="boldcode"><strong><font face="Lucida Console">break       elif </font></strong></span><font face="Lucida Console">10 <= val < 20: newState = "TENS";</font><span class="boldcode"><strong><font face="Lucida Console"> break     </font></strong></span></code><code class="section"><span class="boldcode"><strong><font face="Lucida Console">  else </font></strong></span><font face="Lucida Console">:             </font><span class="boldcode"><strong><font face="Lucida Console">print </font></strong></span><font face="Lucida Console">" *%2.1f+" % val, val = math_func(val)</font><span class="boldcode"><strong><font face="Lucida Console">           print </font></strong></span><font face="Lucida Console">" >>"    </font><span class="boldcode"><strong><font face="Lucida Console">return </font></strong></span><font face="Lucida Console">(newState, val)</font><span class="boldcode"><strong><font face="Lucida Console">def </font></strong><strong><font face="Lucida Console">math_func</font></strong></span><font face="Lucida Console">(n):    </font><span class="boldcode"><strong><font face="Lucida Console">from </font></strong></span><font face="Lucida Console">math </font><span class="boldcode"><strong><font face="Lucida Console">import </font></strong></span><font face="Lucida Console">sin    </font><span class="boldcode"><strong><font face="Lucida Console">return </font></strong></span><font face="Lucida Console">abs(sin(n))*31</font><span class="boldcode"><strong><font face="Lucida Console">if </font></strong></span><font face="Lucida Console">__name__== "__main__":    m = StateMachine()   </font></code><code class="section"><font face="Lucida Console"> m.add_state("ONES", ones_counter)    m.add_state("TENS", tens_counter)    m.add_state("TWENTIES", twenties_counter)    m.add_state("OUT_OF_RANGE", None, end_state=1)    m.set_start("ONES")    m.run(1)            </font></code></pre>
</td>
</tr>
</table>

---
layout: post
title: ! '[转] 嵌入式单地址空间中实现动态加载的过程'
author: gavinkwoe
date: !binary |-
  MjAwOC0wOS0xMSAwMDo0MjoyMyArMDgwMA==
date_gmt: !binary |-
  MjAwOC0wOS0xMCAxNjo0MjoyMyArMDgwMA==
---
转至：<a href="http://blog.csdn.net/pengzhenwanli/archive/2008/04/23/2319412.aspx#875603">http://blog.csdn.net/pengzhenwanli/archive/2008/04/23/2319412.aspx#875603</a>
<p class="MsoNormal"><span>之前有一篇文章是关于嵌入式单地址空间实现动态加载的想法，里面描述的是我根据相关资料进行猜测的地方，以及从技术上来说，可能需要的技术，最近难得有空闲时间，我实现了一下动态加载的。目前已经成功实现，下面说一下实现的过程。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span>先说一下实现此技术需要的平台：</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">OS</span></span><span>：</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">Nucleus</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">CPU</span></span><span>：</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ARM7+cache</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">Baseband</span></span><span>：</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">VT3406</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">ADS1.2</span></span>
<p class="MsoNormal"><span>说一下这些东西的来历，</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">Nucleus</span></span><span>是实时嵌入式单地址空间操作系统，</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">CPU</span></span><span>是介于</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ARM7</span></span><span>与</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ARM9</span></span><span>之间的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">CPU</span></span><span>，</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">BB</span></span><span>芯片是</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">VIA</span></span><span>出的，这些东西目前都已经收掉不再使用，我也正好离职，从而有时间去实现一下动态加载的问题。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span>从理论上来说，动态加载很简单，只需要把当前的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">PC</span></span><span>指针指向下一句执行的语句即可。也就是使用如下的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ASM</span></span><span>就可以实现：</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">MOV PC, Address</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这样就可以顺利执行程序，在我实现的时候，考虑如下问题，程序执行如何返回，参数如何传递，程序执行完毕返回到哪里。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这些问题的解决，看起来比较复杂，其实很简单，程序的返回是放在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>中，这样在上一个函数调用的时候，只要</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>的值不变，这样可以在下一个函数调用的时候，同样使用</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>，这样就可以顺利返回。关于参数传递，由于</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ARM</span></span><span>中使用</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">r0-r3</span></span><span>传递参数，这样只要不更改</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">r0-r3</span></span><span>，就可以顺利传递参数。这个地方想明白，我用了好久，特别是返回地址的问题，程序如何执行，应该返回哪里。解决方法如下</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>实现</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DynamicLoader(UINT8 *pAddress)</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">MOV PC, R0</span></span>
<p class="MsoNormal"><span>这个地方一定要用</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ASM</span></span><span>实现，否则无法完成需要的功能。由于在调用此函数时，已经把函数的返回地址放到</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>中，具体</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ASM</span></span><span>如下：</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">MOV r0,address</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">BL DynamicLoader</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>由于</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DynamicLoaer</span></span><span>的实现问题，没有实际的返回，也就是不需要使用</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">BX lr</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这样来做为函数的返回。这是由于</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">R0</span></span><span>所指向的一个函数的开始地址，从</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DynamicLoader</span></span><span>开始，其实执行的是另一个函数，这里的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DynamicLoader</span></span><span>只是起到了一个跳转的作用。但是又必须使用函数调用的方式来进行，而不能直接跳转，否则函数没有办法返回。由于</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">BL</span></span><span>的时候填充了</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>，这样在下一个由于实际调用不是使用的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">B</span></span><span>指令，因为并没有设置</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>，这样仍旧是在调用</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DynamicLoader</span></span><span>时的</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LR</span></span><span>，因此可以正确返回。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>函数可以正确调用并返回，这是程序很大的一个进步，这样就可以实际构造可以运行的程序了。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>下面说一下</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ADS</span></span><span>编译为二进制可执行文件的问题，使用编译器如果一开始把所有的数据都放好，这样包括全局变量和静态变量，以及函数的执行地址等，都已在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>的时候根据指定规则确定实际的运行地址，也就是说所有的函数的实际运行地址在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>的时候已经确定。这样对于动态运行来说是不可行的，因为既然要动态加载，就需要所有地址都是静态的，因为每次对于读入内存的数据，起始地址是不缺定的，因此不能再</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>时把所有的地址固定死。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>解决这个问题有两种方式，一种是在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">scatter loader</span></span><span>中把程序的可执行地址固定好，在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>时不</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>实际的数据，而在系统启动的时候，把这部分可执行文件拷贝的固定的地址，这样可以作为一个整体运行。但是这种方式由问题，就是应用的大小什么的都是固定死的，不能太灵活，不能根据应用实际调整。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这里使用另外一种方式，选择程序不在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>的时候把所有的地址固定死，而是使用相对独立的函数调用方式。如下：</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>原来的方式可能使这这样</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';"><span>       </span>BL 0x10008;</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>而使用相对的地址程序如下：</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';"><span>       </span>ADD r5,pc,#18</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';"><span>       </span>BL r5</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这样虽然多了一句，但是可以做到函数的运行地址是动态指定的，而不是编译为固定的地址。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>其实</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">ADS</span></span><span>提供了把函数编译为独立地址的方式，</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';"><span>       </span>COMPILER</span></span><span>使用如下的参数</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">/ropi/rwpi</span></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';"><span>       </span>LINK</span></span><span>使用如下的参数</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">-rwpi &ndash;ropi</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>就可以把编译的程序做到运行时地址是独立的。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>从上面来开，编译时地址的问题，还有运行时加载的问题，都已经顺利解决。但是这里还有一个问题，就是如何确保动态应用如何每次在使用的时候，都从固定的入口进入的问题。也就是说，虽然有了内存中的运行地址，但是如何保证每次都从固定的函数开始执行呢？如果每次都从编译的可执行文件</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">0</span></span><span>地址开始执行，没有办法保证每次调用的是同一个函数。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这个可以通过</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>来保证每次是同一个函数在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">0</span></span><span>地址，使用如下的参数</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span style="font-family: 'Times New Roman';">-first DyanmicAppEntry</span></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这样就可以保证</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">DyanmicAppEntry</span></span><span>的入口地址为可执行文件的开始了。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>上面的文章解决了动态编译和加载的问题，下面说一下动态应用的问题。如果要使一个应用有价值，比然需要提供本地的功能调用，而且对于手机来说，系统已经基本上实现了大多数的功能，如果在动态应用中再重复实现一些功能，可以说既浪费了空间，又浪费了时间。而且对于硬件相关的功能，必须通过本地调用来进行，这样就需要如何把本地调用传入动态应用中。如上文所说，本地的调用地址都是在</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">LINK</span></span><span>的时候确定的没有办法直接在动态应用中使用，这样需要在运行时把本地调用传入动态应用，由于动态应用的入口还有好几个参数可以使用，这样就可以构造一张系统调用的表，在运行的时候传入动态应用，这样可以通过表来调用系统功能，这样就解决了系统本地调用的问题。</span><span lang="EN-US"></span>
<p class="MsoNormal"><span lang="EN-US"><span><span style="font-family: 'Times New Roman';">       </span></span></span><span>这里要特别说一下安全的问题，由于动态应用是直接更改</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">PC</span></span><span>指针运行的，这样，如果应用出错，系统可能就</span><span lang="EN-US"><span style="font-family: 'Times New Roman';">CRASH</span></span><span>了，无法再继续运行，而且由于可以调用本地系统调用，可能做许多意想不到的功能，这样就可以在系统调用的时候</span><span lang="EN-US"></span>
<p class="MsoNormal"><span>增加一个中间层，一些核心功能，必须满足一定的权限在可以调用。</span>

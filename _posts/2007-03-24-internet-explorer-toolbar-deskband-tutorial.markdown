---
layout: post
title: Internet Explorer Toolbar (Deskband) Tutorial
author: Alvin
date: !binary |-
  MjAwNy0wMy0yNCAyMTo1MDoyOSArMDgwMA==
date_gmt: !binary |-
  MjAwNy0wMy0yNCAxMzo1MDoyOSArMDgwMA==
---
转至<a href="http://www.codeproject.com">http://www.codeproject.com</a>
<ul class="download">
<li>Download Toolbar Binary - 20Kb </li>
<li><font color="#800080">Download Source - 21 Kb</font> </li></ul>
 
<h2>Introduction </h2>
<p nd="1">Having recieved a number of requests for a tutorial of sorts on developing Internet Explorer Toolbars with the RBDeskband and CWindowImpl wizards that I created, I have come up with a simple sample toolbar which can be used as a reference when developing your own toolbars or explorer bars. The tutorial will walk you through the stages of developing a toolbar for IE that is very similar to the Address bar that is already present in IE. I wanted to do a tutorial that would provide a realistic sample and would produce an end result that could be used by others after the tutorial was finish. So, the tutorial is going to show you how to develop an IE toolbar to get stock quote information from The Motley Fool website. So with that, let us get started. 
<h2>Prequisites </h2>
<p nd="2">This tutorial assumes that you already know how to program in C++ and know some information about ATL and COM. To work through this tutorial, you will need the following installed on your development machine: 
<ul>
<li nd="3">Visual C++6 installed </li>
<li nd="4">RBDeskBand ATL Object Wizard (Version 2.0) [<a href="http://www.codeproject.com/atl/rbdeskband.asp"><font color="#800080">get it here</font></a>] </li>
<li nd="5">CWindowImpl ATL Object Wizard [<a href="http://www.codeproject.com/atl/rbcwindowimpl.asp"><font color="#800080">get it here</font></a>] </li></ul>
<h2>The Framework </h2>
<p nd="6">The IE toolbar consists of a COM component supporting IDeskband and a few other necessary interfaces for which IE looks for when loading registered toolbars, explorer bars and deskbands. The RBDeskband ATL Object Wizard provides most of the framework for this article. What we will need to do is create our project, a new COM object to house our toolbar, and a few CWindowImpl classes using the CWindowImpl ATL Object Wizard. Then connecting these parts together we will produce the IE toolbar in the picture at the top of the article. Visually the toolbar consists of an editbox and a toolbar with one button on it. In actuality the toolbar consists of the fore mentioned and a non visible window that is used to reflect messages to the Toolbar window, which will process or forward messges to itself and the edit box. 
<h2>Creating The Shell </h2>
<p nd="7">We will not work through the steps in creating the shell for our toolbar. 
<h3>Creating The Project </h3>
<ul>
<li nd="8">If you have not done so already, start Visual C++6. </li>
<li nd="9">Then, from the File menu select New menu item; the New Dialog pops up. </li>
<li nd="10">In the New Dialog, select the Projects tab, if not already selected. </li>
<li nd="11">Select ATL COM AppWizard from the list view, if not already selected. </li>
<li nd="12">In the Project name, type "MotleyFool". See Figure 1. </li>
<li nd="13">Click the OK Button. </li></ul><center nd="14"> 
Figure 1. New Dialog. </center>
<ul>
<li nd="15">The ATL COM AppWizard will kick in. </li>
<li nd="16">Clicking the Finish Button, accepting the default AppWizard attributes. See Figure 2. </li>
<li nd="17">The New Project Information Dialog will present itself requesting confirmation of your project settings. </li>
<li nd="18">Click the OK Button. </li></ul><center nd="19"> 
Figure 2. ATL COM AppWizard. </center>
<h3>Creating The DeskBand Object </h3>
Now that we have our project container we need to add our IDeskBand derived component so that the DLL actually exposes something. 
<ul>
<li nd="21">From the Insert menu, select New ATL Object menu item; the ATL Object Wizard dialog is invoked. </li>
<li nd="22">In the ATL Object Wizard dialog, select the RadBytes Category. If this category is missing then make sure that the RBDeskband and CWindowImpl ATL Object Wizards are installed. </li>
<li nd="23">Next select the DeskBand item from the Objects list. </li>
<li nd="24">Click the Next button to invoke the ATL Object Wizard Properties dialog for the Deskband object. See Figure 3. </li>
<li nd="25">On the Names property page, type "StockBar" into the Short Name field. See Figure 4. </li>
<li nd="26">Select the DeskBand ATL Object Wizard property page </li>
<li nd="27">Check the Internet Explorer Toolbar checkbox. See Figure 5. </li>
<li nd="28">Click the OK button on the ATL Object Wizard Properties Dialog. The ATL Object Wizard will create the files necessary for our DeskBand's base implementation. </li></ul><center nd="29"> 
Figure 3. ATL Object Wizard. </center><center nd="30"> 
Figure 4. ATL Object Wizard Properties - Names. </center><center nd="31"> 
Figure 5. ATL Object Wizard Properties - DeskBand ATL Object Wizard </center>
Now our project has the DeskBand implementation that we will modify to produce the toolbar pictured at the top of the article. First we will create the window classes we will need and then come back to the Desbkand object and update it to use our window classes. 
<h2>Creating The Window Classes </h2>
<p nd="32">So back in the Framework section we said that we would need three window classes. One for the Edit Box, one for the toolbar, and one for message reflection back to the toolbar. Let us now create these window classes. 
<h3>The Edit Window </h3>
<p nd="33">We need to create a derived class from the standard EDIT button window class because we are going to be adding methods to our class to help support functionality of the toolbar. This is one reason why we cannot use a CContainedWindow object directly. 
<ul>
<li nd="34">From the Insert menu, select New ATL Object menu item; the ATL Object Wizard dialog is invoked. </li>
<li nd="35">In the ATL Object Wizard dialog, select the RadBytes Category. If this category is missing then make sure that the RBDeskband and CWindowImpl ATL Object Wizards are installed. </li>
<li nd="36">Next select the CWindowImpl item from the Objects list. </li>
<li nd="37">Click the Next button to invoke the ATL Object Wizard Properties dialog for the Deskband object. See Figure 3. </li>
<li nd="38">On the Names property page, type "EditQuote" into the Short Name field. </li>
<li nd="39">Select the CWindowImpl property page. See Figure 6. </li>
<li nd="40">Select the SUPERCLASS radio button from the DECLAR_WND_* group. </li>
<li nd="41">In the Window Class Name field, type "EDITQUOTE". </li>
<li nd="42">In the Original Class Name list, select the EDIT listbox item. See Figure 7. </li>
<li nd="43">Click the OK button on the ATL Object Wizard Properties Dialog. The ATL Object Wizard will create the files necessary for our CWindowImpl derived class implementation. </li></ul><center nd="44"> 
Figure 6. ATL Object Wizard Properties - Names. </center><center nd="45"> 
Figure 7. ATL Object Wizard Properties - CWindowImpl. </center>
<h3>The Toolbar Window </h3>
<p nd="46">We need to create a derived class from the standard TOOLBARCLASSNAME window class because we are going to be adding methods to our class to help support functionality of the toolbar. It will also be the parent for the edit box and the window which the IE host will request from our DeskBand. 
<ul>
<li nd="47">From the Insert menu, select New ATL Object menu item; the ATL Object Wizard dialog is invoked. </li>
<li nd="48">In the ATL Object Wizard dialog, select the RadBytes Category. If this category is missing then make sure that the RBDeskband and CWindowImpl ATL Object Wizards are installed. </li>
<li nd="49">Next select the CWindowImpl item from the Objects list. </li>
<li nd="50">Click the Next button to invoke the ATL Object Wizard Properties dialog for the Deskband object. See Figure 3. </li>
<li nd="51">On the Names property page, type "MFToolbar" into the Short Name field. </li>
<li nd="52">Select the CWindowImpl property page. See Figure 8. </li>
<li nd="53">Select the SUPERCLASS radio button from the DECLAR_WND_* group. </li>
<li nd="54">In the Window Class Name field, type "MOTLEYFOOLTOOLBAR". </li>
<li nd="55">In the Original Class Name list, select the TOOLBARCLASSNAME listbox item. See Figure 9. </li>
<li nd="56">Click the OK button on the ATL Object Wizard Properties Dialog. The ATL Object Wizard will create the files necessary for our CWindowImpl derived class implementation. </li></ul><center nd="57"> 
Figure 8. ATL Object Wizard Properties - Names. </center><center nd="58"> 
Figure 9. ATL Object Wizard Properties - CWindowImpl. </center>
<h3>The Reflection Window </h3>
<p nd="59">We need to create a reflection window. It's just a CWindowImpl window implmented class. We are going to be adding a small bit of functionality just to create the toolbar object and be able to access the toolbar member from our deskband class. 
<ul>
<li nd="60">From the Insert menu, select New ATL Object menu item; the ATL Object Wizard dialog is invoked. </li>
<li nd="61">In the ATL Object Wizard dialog, select the RadBytes Category. If this category is missing then make sure that the RBDeskband and CWindowImpl ATL Object Wizards are installed. </li>
<li nd="62">Next select the CWindowImpl item from the Objects list. </li>
<li nd="63">Click the Next button to invoke the ATL Object Wizard Properties dialog for the Deskband object. See Figure 3. </li>
<li nd="64">On the Names property page, type "ReflectionWnd" into the Short Name field. See Figure 10. </li>
<li nd="65">We will not change any of the CWindowImpl property page values this time. </li>
<li nd="66">Click the OK button on the ATL Object Wizard Properties Dialog. The ATL Object Wizard will create the files necessary for our CWindowImpl derived class implementation. </li></ul><center nd="67"> 
Figure 10. ATL Object Wizard Properties - Names. </center>
<h2>Adding The Details </h2>
<p nd="68">Now that we have our window classes available we can add our functionality for our toolbar to the appropriate window classes. Let us start with the deepest window class and work our way back out. 
<h3>The EditQuote Details </h3>
<p nd="69">For the EditQuote implementation, we need to be able to process keystrokes from the user and let the host that created our deskband object know our edit box has focus. To accomplish the first part, we need to look ahead and see that our DeskBand object will be implementing the IInputObject interface. So the host will query for that interface and know that we want to recieve messages and be given the chance to recieve focus. When the host sends our band messages to process they come through the IInputObject::TranslateAccelerator method. Our DeskBand will implement this method and it is best if our edit box, which will process the message, copy the TranslateAcceleratorIO method definition so our deskband can forward the message easily through a logical method call. <center nd="70"> 
Figure 11. FileView Pane. </center>
In the FileView pane (See Figure 11), double click the EditQuote.h item under Header Files. This will open the header file in the editing area. We now need to define the method definition for TranslateAcceleratorIO. To do this, add below the virtual CEditQuote destructor the following line of code: 
<pre lang="c++" nd="71">STDMETHOD(TranslateAcceleratorIO)(LPMSG lpMsg);</pre>
Now Open the EditQuote.cpp source file and add the implementation of TranslateAcceleratorIO to the file 
<pre nd="72" langu="c++">STDMETHODIMP CEditQuote::TranslateAcceleratorIO(LPMSG lpMsg){   TranslateMessage(lpMsg);   DispatchMessage(lpMsg);   <span class="cpp-keyword">return</span> S_OK;}</pre>
Now our DeskBand implementation can call this message and the edit box will process the key strokes properly. But wait, our edit box should notify the toolbar to load the quote details entered if the key stroke is the enter key. For this, we will need to define a message id and send that message to the parent window to process. In the EditQuote.h header file below the include statement, add the definition of our message id as shown below in bold. 
<pre lang="c++"><span class="cpp-preprocessor" nd="73">#include <commctrl.h></span><strong><span class="cpp-keyword">const</span> <span class="cpp-keyword">int</span> WM_GETQUOTE = WM_USER + <span class="cpp-literal">1024</span>;</strong>			</pre>
In our EditQuote.cpp file we will add code to our TranslateAcceleratorIO method to process the enter key. Add the code below in bold to the EditQuote.cpp file. 
<pre lang="c++" nd="74">STDMETHODIMP CEditQuote::TranslateAcceleratorIO(LPMSG lpMsg){<strong>   <span class="cpp-keyword">int</span> nVirtKey = (<span class="cpp-keyword">int</span>)(lpMsg->wParam);   <span class="cpp-keyword">if</span> (VK_RETURN == nVirtKey)   {      <span class="cpp-comment">// remove system beep on enter key by setting key code to 0</span>      lpMsg->wParam = <span class="cpp-literal">0</span>;      ::PostMessage(GetParent(), WM_GETQUOTE, <span class="cpp-literal">0</span>, <span class="cpp-literal">0</span>);      <span class="cpp-keyword">return</span> S_OK;   }</strong>   TranslateMessage(lpMsg);   DispatchMessage(lpMsg);   <span class="cpp-keyword">return</span> S_OK;}</pre>
Now our edit box will notify the parent when the user presses the enter key so that the parent can retrieve the requested ticker symbol details, this part will be implemented when we get to the toolbar details. 
<p nd="75">The first part of the Edit boxes implementation is finished. Now we need to be able for the edit box to have the deskband notify the host that we have focus or that we don't have focus any longer. To do this we will need to add a method for the deskband to pass us it's address so that we can call a method of the deskband class. These next steps will involve adding code to the CEditQuote class and to our Deskband class implementation. 
<p nd="76">Open the EditQuote.h file and add a forward reference to the CStockBar class so that we can defined our methods and members in our class header without knowing the implementation details of our deskband class, add the line in bold. 
<pre lang="c++" nd="78"><span class="cpp-preprocessor" nd="77">#include <commctrl.h></span><span class="cpp-keyword">const</span> <span class="cpp-keyword">int</span> WM_GETQUOTE = WM_USER + <span class="cpp-literal">1024</span>;<strong><span class="cpp-keyword">class</span> CStockBar;</strong></pre>
For our class to notify the host that our deskband has focus, we need to add a message handler for EN_SETFOCUS. Add the command code handler code below in bold to your EditQuote.h file. 
<pre lang="c++" nd="79">   BEGIN_MSG_MAP(CEditQuote)<strong>      COMMAND_CODE_HANDLER(EN_SETFOCUS, OnSetFocus)</strong>   END_MSG_MAP()</pre>
Then add the method definition for OnSetFocus to the header file below the commented out handler prototypes as follows below in bold. 
<pre lang="c++"><span class="cpp-comment">// Handler prototypes:</span><span class="cpp-comment">// LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</span><span class="cpp-comment">// LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</span><span class="cpp-comment">// LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);</span><strong>   LRESULT OnSetFocus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</strong></pre>
Before we implement the OnSetFocus method, we need to define a method for our deskband to tells of it's address and to retain that address for later use. Add the following lines of code to your EditQuote.h file below the TranslateAcceleratorIO definition. 
<pre lang="c++" nd="80">   <span class="cpp-keyword">void</span> SetBand(CStockBar* pBand);<span class="cpp-keyword">private</span>:   CStockBar* m_pBand;</pre>
Now we can move to your EditQuote.cpp source file and implement the message handler, the SetBand method, and update the TranslateAcceleratorIO method for focus change. At the top of the EditQuote.cpp file add the following includes to the include list as shown below in bold. 
<pre lang="c++"><span class="cpp-preprocessor" nd="81">#include "stdafx.h"</span><span class="cpp-preprocessor" nd="82">#include "EditQuote.h"</span><strong>#include "MotleyFool.h"<span class="cpp-preprocessor">#include "StockBar.h"</span></strong></pre>
Now when we can use the methods of the CStockBar class in our code. Add to the end of the constructor, the initalization of m_pBand. Don't forget the colon operator. 
<pre lang="c++" nd="83">CEditQuote::CEditQuote()<strong>: m_pBand(NULL)</strong>{}</pre>
Next we will add the SetBand implementation to our CEditQuote class. Notice that since it is not a com object we don't call AddRef or Release on it. It's just a pointer to the class and when it's destroyed our CEditQuote instance will also be destroyed. We could have also done this inline in our header file. 
<pre lang="c++" nd="84"><span class="cpp-keyword">void</span> CEditQuote::SetBand(CStockBar* pBand){   m_pBand = pBand;}</pre>
Next we need to add our message handler for our EN_SETFOCUS message. Add the code below to the end of the EditQuote.cpp source file. 
<pre lang="c++" nd="85">LRESULT CEditQuote::OnSetFocus(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled){   <span class="cpp-comment">//Notify host that our band has the focus so TranslateAcceleratorIO </span>   <span class="cpp-comment">//messages are directed towards our band.</span>   <span class="cpp-keyword">if</span> (m_pBand) m_pBand->FocusChange(TRUE);   <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;}</pre>
We have one more section of code to add to our CEditQuote implementation then we can move to our CStockBar class to define and implement the FocusChange method. Add the following code to the CEditQuote TranslateAcceleratorIO method as shown in bold. We add this code so the host knows that we are no longer needing messages. 
<pre lang="c++" nd="86">STDMETHODIMP CEditQuote::TranslateAcceleratorIO(LPMSG lpMsg){   <span class="cpp-keyword">int</span> nVirtKey = (<span class="cpp-keyword">int</span>)(lpMsg->wParam);   <span class="cpp-keyword">if</span> (VK_RETURN == nVirtKey)   {      <span class="cpp-comment">// remove system beep on enter key by setting key code to 0</span>      lpMsg->wParam = <span class="cpp-literal">0</span>;      ::PostMessage(GetParent(), WM_GETQUOTE, <span class="cpp-literal">0</span>, <span class="cpp-literal">0</span>);      <span class="cpp-keyword">return</span> S_OK;   }<strong>   <span class="cpp-keyword">else</span> <span class="cpp-keyword">if</span> (WM_KEYDOWN == lpMsg->message && nVirtKey == VK_TAB)   {      <span class="cpp-comment">// we no longer need messages forwarded to our band</span>      <span class="cpp-keyword">if</span> (m_pBand) m_pBand->FocusChange(FALSE);      <span class="cpp-keyword">return</span> S_FALSE;   }</strong>   TranslateMessage(lpMsg);   DispatchMessage(lpMsg);   <span class="cpp-keyword">return</span> S_OK;}</pre>
Open the StockBar.h header file and add the definition of FocusChange to it as shown below in bold. 
<pre lang="c++" nd="87"><span class="cpp-comment">// IStockBar</span><span class="cpp-keyword">public</span>:<strong>   <span class="cpp-keyword">void</span> FocusChange(BOOL bHaveFocus);</strong></pre>
Now open the StockBar.cpp source file and add the implementation of FocusChange to it at the bottom. 
<pre lang="c++" nd="88"><span class="cpp-keyword">void</span> CStockBar::FocusChange(BOOL bHaveFocus){   <span class="cpp-keyword">if</span> (m_pSite)   {      IUnknown* pUnk = NULL;      <span class="cpp-keyword">if</span> (SUCCEEDED(QueryInterface(IID_IUnknown, (LPVOID*)&pUnk)) && pUnk != NULL)      {         m_pSite->OnFocusChangeIS(pUnk, bHaveFocus);         pUnk->Release();         pUnk = NULL;      }   }}</pre>
We have finished off the work needed for the edit box to work properly in our toolbar. Now we need to build our toolbar up so that it has a button and contains our edit box. Then we will add the nessecities to our reflection window and update our IDeskBand to provide the correct information to our host. We are almost there. If you were to compile the project and run it, it would except that the band would look like the following in figure X. 
<h3>The MFToolbar Details </h3>
<p nd="89">For the implementation of the MFToolbar window, we need to be able to have it do the following things. It must be able to process the WM_GETQUOTE message from the EditQuote window, communicate with the web browser in which the toolbar is located, create the buttons and place the child windows on itself, forward messages to the EditQuote child window and size itself appropriately to the users actions. 
<p nd="90">So, the first thing we should do since our toolbar is going to contain an instance of CEditQuote is include the header file for the CEditQuote class. We will do this by opening the MFToolbar.h file and inserting the include statement for the CEditQuote class as shown in bold below. 
<pre lang="c++"><span class="cpp-preprocessor" nd="91">#include <commctrl.h></span><strong>#include "EditQuote.h"</strong>		</pre>
Next we need to add a member to our toolbar class for the CEditQuote class. We will do this by adding a private section to the end of our class and defining a member variable as shown below in bold. 
<pre lang="c++" nd="92">   CMFToolbar();   <span class="cpp-keyword">virtual</span> ~CMFToolbar();<strong><span class="cpp-keyword">private</span>:   CEditQuote m_EditWnd;</strong></pre>
Now that we have our member defined for our EditQuote window, we need to forward window messages to it so that keyboard inputs are processed appropriately. We do this by updating the toolbar message map to chain messages to our member as shown below in bold. 
<pre lang="c++" nd="93">   BEGIN_MSG_MAP(CMFToolbar)<strong>      CHAIN_MSG_MAP_MEMBER(m_EditWnd)</strong>   END_MSG_MAP()</pre>
Looking forward, our deskband will need to get the EditQuote member to deterimine if it has focus and also to make it function. We could just expose the EditQuote member directly by having made it a public member instead of private, but by making it private we can expose a method that will expose our member giving us flexibility later to modify the class if the need should arise. So to expose the EditQuote member, we will add a fuction to our toolbar class to return the reference to the EditQuote member. In the toolbar header file, add the method definition and implementation below in bold to it. 
<pre lang="c++" nd="94">   CMFToolbar();   <span class="cpp-keyword">virtual</span> ~CMFToolbar();<strong>   <span class="cpp-keyword">inline</span> CEditQuote& GetEditBox() {<span class="cpp-keyword">return</span> m_EditWnd;};</strong></pre>
Now we will create our toolbar window. Our toolbar consists of the EditQuote box and a button with an icon and text on it. To house the icon, our toolbar will need an image list handle to send to the toolbar window. So we need to add a few things to our toolbar header file before we go and implement the toolbar's creation. The first thing we will add is the member variable for our image list. Add the line in bold below to your toolbar header file. 
<pre lang="c++" nd="95"><span class="cpp-keyword">private</span>:   CEditQuote m_EditWnd;<strong>   HIMAGELIST m_hImageList;</strong></pre>
Then we will add a message handler to our toolbar's message map and define the message handlers function definition to our header file and the follow lines of code in bold to your header file. 
<pre lang="c++" nd="96">   BEGIN_MSG_MAP(CMFToolbar)      CHAIN_MSG_MAP_MEMBER(m_EditWnd)<strong>      MESSAGE_HANDLER(WM_CREATE, OnCreate)</strong>   END_MSG_MAP()<span class="cpp-comment">// Handler prototypes:</span><span class="cpp-comment">//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);</span><strong>   LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</strong></pre>
Before we can implement our toolbar's creation, we need to create a icon resource that our toolbar button will use next to its text. So go to the resource view and add a new icon to the project resources. You can do this by right clicking on "MotleyFool resources" and selecting "Insert..." from the context menu. In the Insert Resource dialog box, select Icon from the Resource type list and click the New button. This will insert a blank icon resource into your project. Rename the icon's resource ID by right clicking on the icon resource in the resource view and selecting the properties menu item from the context menu. Change the id to IDI_MOTLEY. Then draw or graciously borrow an icon from The Motley Fool to use on the toolbar. I graciously borrowed the icon from their website and adapted it into the icon. 
Now we can implement it our toolbars creation. Open the MFToolbar source file and implement the details of the toolbar creation as described below. 
First we need to include the project resource file so we can use the icon ID in our code. Add the line in bold below to our toolbar's source file as shown. 
<pre lang="c++"><span class="cpp-preprocessor" nd="97">#include "stdafx.h"</span><strong>#include "resource.h"</strong><span class="cpp-preprocessor" nd="98">#include "MFToolbar.h"</span></pre>
Next we need to update our constructor implementation. We need to initialize our handle to the image list by setting it to NULL. Don't forget the colon. 
<pre lang="c++" nd="99">CMFToolbar::CMFToolbar()<strong>: m_hImageList(NULL)</strong>{}</pre>
Next we need to update our destructor, it should destroy the image list and destroy the window if it has not yet been destroyed. 
<pre lang="c++" nd="100">CMFToolbar::~CMFToolbar(){<strong>   ImageList_Destroy(m_hImageList);   <span class="cpp-keyword">if</span> (IsWindow()) DestroyWindow();</strong>}</pre>
Before we can implement our toolbar's creation, we need to add a resource symbol to our project for the toolbar button's ID. We could just use a <code><span class="cpp-preprocessor" nd="101">#define</span></code> statement at the top of the source file, but for cleanliness and since we are already including the resource.h file, we will add it to our resource file. Go to the "View" menu and select "Resource Symbols" menu item. Click the "New" button on the Resource Symbols dialog. Then enter a name of "IDM_GETQUOTE" and click OK. Then close the Resource Symbols dialog. 
Now we can create our toolbar, we defined the OnCreate method in our header file and need to now implement it. Add the following function and its implementation to the end of the toolbar source file. 
<div class="precollapse" id="premain24" style="WIDTH: 100%"><img id="preimg24" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="24" alt="" /><span id="precollapse24" style="MARGIN-BOTTOM: 0px; CURSOR: hand" nd="102" preid="24"> Collapse</span></div>
<pre lang="c++" id="pre24" style="MARGIN-TOP: 0px" nd="103">LRESULT CMFToolbar::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){   <span class="cpp-comment">// buttons with images and text</span>   SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, <span class="cpp-literal">0</span>, (LPARAM)TBSTYLE_EX_MIXEDBUTTONS);   <span class="cpp-comment">// Sets the size of the TBBUTTON structure.</span>   SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, <span class="cpp-keyword">sizeof</span>(TBBUTTON), <span class="cpp-literal">0</span>);   <span class="cpp-comment">// Set the maximum number of text rows and bitmap size.</span>   SendMessage(m_hWnd, TB_SETMAXTEXTROWS, <span class="cpp-literal">1</span>, <span class="cpp-literal">0L</span>);   <span class="cpp-comment">// add our button's caption to the toolbar window</span>   TCHAR* pCaption = _T("Get Quote");   <span class="cpp-keyword">int</span> iIndex = ::SendMessage(m_hWnd, TB_ADDSTRING, <span class="cpp-literal">0</span>,(LPARAM)pCaption);   <span class="cpp-comment">// load our button's icon and create the image list to house it.</span>   HICON hMotley = LoadIcon(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_MOTLEY));   m_hImageList = ImageList_Create(<span class="cpp-literal">16</span>,<span class="cpp-literal">16</span>, ILC_COLOR16, <span class="cpp-literal">1</span>, <span class="cpp-literal">0</span>);   <span class="cpp-keyword">int</span> iImageIndex = ImageList_AddIcon(m_hImageList, hMotley);   DestroyIcon(hMotley);   <span class="cpp-comment">// Set the toolbar's image</span>   ::SendMessage(m_hWnd, TB_SETIMAGELIST, <span class="cpp-literal">0</span>, (LPARAM)m_hImageList);   <span class="cpp-comment">// add the button for the toolbar to the window</span>   TBBUTTON Button;   ZeroMemory((<span class="cpp-keyword">void</span>*)&Button, <span class="cpp-keyword">sizeof</span>(TBBUTTON));   Button.idCommand = IDM_GETQUOTE;   Button.fsState = TBSTATE_ENABLED;   Button.fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT;   Button.dwData = <span class="cpp-literal">0</span>;   Button.iString = iIndex;   Button.iBitmap = <span class="cpp-literal">0</span>;   ::SendMessage(m_hWnd, TB_INSERTBUTTON, <span class="cpp-literal">0</span>, (LPARAM)&Button);   <span class="cpp-comment">// create our EditQuote window and set the font.</span>   RECT rect = {<span class="cpp-literal">0</span>,<span class="cpp-literal">0</span>,<span class="cpp-literal">0</span>,<span class="cpp-literal">0</span>};   m_EditWnd.Create(m_hWnd, rect, NULL, WS_CHILD|WS_VISIBLE, WS_EX_CLIENTEDGE);   m_EditWnd.SetFont(<span class="cpp-keyword">static_cast</span><HFONT>(GetStockObject(DEFAULT_GUI_FONT)));   <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;}</pre>
If you try to compile at this point, you will see that there are unresolved externals for the image list method calls. We need to add a library to the project. To do this select the "Project|Settings" menu item. On the Project Settings dialog, Select All Configurations from the "Settings For" combo box. Then select the "Link" tab and append to the "Object/Library modules" edit box "comctl32.lib". Then click OK. If you compile the project now, it will compile successfully and the image list unresolved externals will disappear. 
We still have a few things we need to do to the Toolbar window. It needs to process Command messages, resopnd to WM_GETQUOTE messages, and resize itself. Let's conquer the latter first. 
To orgainze the tooblar correctly, we should have the toolbar responsd to WM_SIZE messages. To do this, we will add to our tooblar header file a message handler for the WM_SIZE message and add a function definition for OnSize which WM_SIZE messages will be sent to. Open our toolbar header file and add the lines in bold below to it as shown. 
<pre lang="c++" nd="104">   BEGIN_MSG_MAP(CMFToolbar)      CHAIN_MSG_MAP_MEMBER(m_EditWnd)      MESSAGE_HANDLER(WM_CREATE, OnCreate)<strong>      MESSAGE_HANDLER(WM_SIZE, OnSize)</strong>   END_MSG_MAP()<span class="cpp-comment">// Handler prototypes:</span><span class="cpp-comment">//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);</span>   LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);<strong>   LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</strong></pre>
Now we need to implement our OnSize function. Open the toolbar source file and add the function implementation below to the end of the file. 
<div class="precollapse" id="premain26" style="WIDTH: 100%"><img id="preimg26" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="26" alt="" /><span id="precollapse26" style="MARGIN-BOTTOM: 0px; CURSOR: hand" nd="105" preid="26"> Collapse</span></div>
<pre lang="c++" id="pre26" style="MARGIN-TOP: 0px" nd="106">LRESULT CMFToolbar::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){   <span class="cpp-comment">// based on the size of the window area minus the size of the toolbar button, </span>   <span class="cpp-comment">// indent the toolbar so that we can place the edit box before the toolbar </span>   <span class="cpp-comment">// button. This will right justify the toolbar button in the toolbar and the </span>   <span class="cpp-comment">// edit box will use the vaction space to the left of the button but after the </span>   <span class="cpp-comment">// toolbar text as it's usable space.</span>   RECT wndRect, btnRect;   GetClientRect(&wndRect);   ::SendMessage(m_hWnd, TB_GETITEMRECT, <span class="cpp-literal">0</span>, (LPARAM)&btnRect);   wndRect.right -= (btnRect.right - btnRect.left);   SendMessage(TB_SETINDENT, wndRect.right - wndRect.left);   <span class="cpp-comment">// put a small spacing gap between the edit box's right edge and the toolbar button's left edge</span>   wndRect.right -= <span class="cpp-literal">3</span>;   m_EditWnd.MoveWindow(&wndRect, FALSE);   <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;}</pre>
We still need to respond to user input for the toolbar button and from the edit box when the user presses the enter key. What we want the toolbar to do is tell the web browser host to navigate to the motely fool website and retrieve the stock quotes requested. First we need for the Deskband object to tell our toolbar window what the web browser instance is so that the toolbar window can communicate with it. To do this, we will add a private member variable and a public method in which the deskband can set the web browser instance. Our window will then use the member variable set to tell the web browser where to navigate and what to retrieve. 
To do this, open the toolbar header file and add the lines in bold to the file. 
<pre lang="c++" nd="107">   CMFToolbar();   <span class="cpp-keyword">virtual</span> ~CMFToolbar();   <span class="cpp-keyword">inline</span> CEditQuote& GetEditBox() {<span class="cpp-keyword">return</span> m_EditWnd;};<strong>   <span class="cpp-keyword">void</span> SetBrowser(IWebBrowser2* pBrowser);</strong><span class="cpp-keyword">private</span>:   CEditQuote m_EditWnd;   HIMAGELIST m_hImageList;<strong>   IWebBrowser2* m_pBrowser;</strong></pre>
Now, open the toolbar source file. We will update the constructor and initialize our member variable to null. Then we will update the toolbar destructor and release the member variable if it hasn't been. Then we will implement the SetBrowser method. 
Initialize the web browser member variable. 
<pre lang="c++" nd="108">CMFToolbar::CMFToolbar(): m_hImageList(NULL)<strong>, m_pBrowser(NULL)</strong>{}</pre>
Release the web browser object if held. 
<pre lang="c++" nd="109">CMFToolbar::~CMFToolbar(){   ImageList_Destroy(m_hImageList);   SetBrowser(NULL);   <span class="cpp-keyword">if</span> (IsWindow()) DestroyWindow();}</pre>
Implement SetBrowser() 
<pre lang="c++" nd="110"><span class="cpp-keyword">void</span> CMFToolbar::SetBrowser(IWebBrowser2* pBrowser){   <span class="cpp-keyword">if</span> (m_pBrowser) m_pBrowser->Release();   m_pBrowser = pBrowser;   <span class="cpp-keyword">if</span> (m_pBrowser) m_pBrowser->AddRef();}</pre>
If you try and compile the project, you will notice that IWebBrowser2 is undefine in our header file. This is because we need to update our stdafx.h header file to include system files that define IWebBrowser2. To do this, open stdafx.h and add the following lines in bold to the file, then recompile. 
<pre lang="c++" nd="111"><span class="cpp-keyword">extern</span> CComModule _Module;<span class="cpp-preprocessor" nd="112">#include <atlcom.h></span><span class="cpp-preprocessor" nd="113">#include <atlwin.h></span><strong><span class="cpp-comment">//</span><span class="cpp-comment">// These are needed for IDeskBand</span><span class="cpp-comment">//</span><span class="cpp-preprocessor">#include <shlguid.h></span><span class="cpp-preprocessor">#include <shlobj.h></span></strong></pre>
Now we can add message handlers for WM_COMMAND and WM_GETQUOTE to our toolbar class to handle the toolbar button being pressed and the enter key being pressed in the edit box by the user. To do this, we will need to add to our toolbar header file message handlers and function definitions for WM_COMMAND and WM_GETQUOTE. We will also need to add a private method which both will call if they need to to preform the same functionality (better than repeating code that does the same thing). So let's add the message handlers to the header file. 
<div class="precollapse" id="premain32" style="WIDTH: 100%"><img id="preimg32" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="32" alt="" /><span id="precollapse32" style="MARGIN-BOTTOM: 0px; CURSOR: hand" nd="114" preid="32"> Collapse</span></div>
<pre lang="c++" id="pre32" style="MARGIN-TOP: 0px" nd="115">   BEGIN_MSG_MAP(CMFToolbar)      CHAIN_MSG_MAP_MEMBER(m_EditWnd)      MESSAGE_HANDLER(WM_CREATE, OnCreate)      MESSAGE_HANDLER(WM_SIZE, OnSize)<strong>      MESSAGE_HANDLER(WM_COMMAND, OnCommand)      MESSAGE_HANDLER(WM_GETQUOTE, OnGetQuote)</strong>   END_MSG_MAP()<span class="cpp-comment">// Handler prototypes:</span><span class="cpp-comment">//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);</span>   LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);   LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);<strong>   LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);   LRESULT OnGetQuote(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</strong></pre>
Now we can add the function delcaration for our GetQuote privaet method. 
<pre lang="c++" nd="116"><span class="cpp-keyword">private</span>:   CEditQuote m_EditWnd;   HIMAGELIST m_hImageList;   IWebBrowser2* m_pBrowser;<strong>   <span class="cpp-keyword">void</span> GetQuote();</strong></pre>
Now let's switch to our source file and implement our message handler functions and the GetQuote method. Add the code below to the end of the toolbar source file. 
<div class="precollapse" id="premain34" style="WIDTH: 100%"><img id="preimg34" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="34" alt="" /><span id="precollapse34" style="MARGIN-BOTTOM: 0px; CURSOR: hand" nd="117" preid="34"> Collapse</span></div>
<pre lang="c++" id="pre34" style="MARGIN-TOP: 0px" nd="118">LRESULT CMFToolbar::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){   <span class="cpp-keyword">if</span> (!HIWORD(wParam))   {      <span class="cpp-keyword">long</span> lSite = LOWORD(wParam);      <span class="cpp-keyword">if</span> ( lSite == IDM_GETQUOTE)      {         GetQuote();         <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;      }   }   <span class="cpp-keyword">return</span> -<span class="cpp-literal">1</span>;}LRESULT CMFToolbar::OnGetQuote(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){   GetQuote();   <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;}<span class="cpp-keyword">void</span> CMFToolbar::GetQuote(){   <span class="cpp-comment">// if we have a web browser pointer then try to navigate to The Motley Fool site to retrieve stock quotes.</span>   <span class="cpp-keyword">if</span> (m_pBrowser)   {      VARIANT vEmpty;      VariantInit(&vEmpty);      m_pBrowser->Stop();      _bstr_t bsSite;      <span class="cpp-comment">// if the user has entered stock quotes then append them to the url</span>      <span class="cpp-keyword">if</span> (m_EditWnd.GetWindowTextLength())      {         BSTR bstrTickers = NULL;         m_EditWnd.GetWindowText(&bstrTickers);         bsSite = "http:<span class="cpp-comment">//quote.fool.com/news/symbolnews.asp?Symbols=";</span>         bsSite += bstrTickers;         SysFreeString(bstrTickers);      }      <span class="cpp-comment">// if the user has not entered any stock quotes then just take them to The Motley Fool website.</span>      <span class="cpp-keyword">else</span>         bsSite = "http:<span class="cpp-comment">//www.fool.com";</span>      <span class="cpp-comment">// have the webrowser navigate to the site URL requested depending on user input.</span>      m_pBrowser->Navigate(bsSite, &vEmpty, &vEmpty, &vEmpty, &vEmpty);   }}</pre>
If you try to compile, you will notice that _bstr_t is undefined. That is because the class is defined in comdef.h. We need to add this to our stdafx.h header file so that we can use it as well as any other class in our project (which we will need to for IInputObject). Open the stdafx.h header file and add the lines in bold to the file as indicated. 
<pre lang="c++"><span class="cpp-preprocessor" nd="119">#include <shlobj.h></span><strong><span class="cpp-comment">// needed for IInputObject and _bstr_t</span><span class="cpp-preprocessor">#include <comdef.h></span></strong></pre>
Our implementation of the toolbar window is complete. Now we can move on to the Reflection window which creates our toolbars and forwards command messages to it. 
<h3>The Reflection Window Details </h3>
For the Reflection Window, it's only purpose is to create the toolbar window (which it doesn't need to really do, but by doing so eases message forwarding) and forward messages to it. The reflection window is not visible, it's just a layer added so that message from the toolbar get to the toolbar. If we didn't have this window present, toolbar messages would get sent to the parent window (which we do not control) and we would never get them. This is not good since we need to respond to WM_COMMAND messages from the toolbar. Thus the need for the reflection window. So let's create the toolbar window and the message forwarding for it. 
Open the ReflectionWnd.h header file. We will need to include the toolbar header file and add a private member variable to our reflection window to create it and to pass it to the message chain. First things first, add the include statement below so we can use the CMFToolbar class. 
<pre lang="c++"><span class="cpp-preprocessor">#include <commctrl.h></span><strong>#include "MFToolbar.h"</strong></pre>
Next add a private member variable to the end of the reflection window class for the toolbar as shown below. 
<pre lang="c++">	CReflectionWnd();   <span class="cpp-keyword">virtual</span> ~CReflectionWnd();<strong><span class="cpp-keyword">private</span>:   CMFToolbar m_ToolbarWnd;</strong></pre>
Next update the reflection window message map to forward messages to the toolbar window as shown below. 
<pre lang="c++">   BEGIN_MSG_MAP(CReflectionWnd)<strong>      CHAIN_MSG_MAP_MEMBER(m_ToolbarWnd)</strong>   END_MSG_MAP()</pre>
We will also need a public function for our deskband class to get at our toolbar window. We will do the same as we did with the EditQuote window by providing a function to get at the member variable indirectly. Add the line of code in bold below to the header file as indicated. 
<pre lang="c++">   CReflectionWnd();   <span class="cpp-keyword">virtual</span> ~CReflectionWnd();<strong>   <span class="cpp-keyword">inline</span> CMFToolbar& GetToolBar() { <span class="cpp-keyword">return</span> m_ToolbarWnd;};</strong></pre>
Lastly, we need to create the toolbar window and will do so in the WM_CREATE message handler for our reflection window. Add the code below in bold to the reflection window header file. Then we will implement the OnCreate method in the source file. 
<pre lang="c++">   BEGIN_MSG_MAP(CReflectionWnd)<strong>      MESSAGE_HANDLER(WM_CREATE, OnCreate)</strong>      CHAIN_MSG_MAP_MEMBER(m_ToolbarWnd)   END_MSG_MAP()<span class="cpp-comment">// Handler prototypes:</span><span class="cpp-comment">//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);</span><span class="cpp-comment">//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);</span><strong>   LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);</strong></pre>
Now open the ReflectionWnd.cpp source file and add the implementation of OnCreate to its end. 
<pre lang="c++"><span class="cpp-keyword">const</span> DWORD DEFAULT_TOOLBAR_STYLE =       <span class="cpp-comment">/*Window styles:*/</span> WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_TABSTOP |      <span class="cpp-comment">/*Toolbar styles:*/</span> TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_LIST | TBSTYLE_CUSTOMERASE |                          TBSTYLE_WRAPABLE |      <span class="cpp-comment">/*Common Control styles:*/</span> CCS_TOP | CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE;LRESULT CReflectionWnd::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){   RECT rect;   GetClientRect(&rect);   m_ToolbarWnd.Create(m_hWnd, rect, NULL, DEFAULT_TOOLBAR_STYLE);   <span class="cpp-keyword">return</span> <span class="cpp-literal">0</span>;}</pre>
You will notice that we defined a constant for the toolbar style. This was done to make the code more readable. 
The only thing left to do to the reflection window code is update the destructor to destory the window if it's still present. 
<pre lang="c++">CReflectionWnd::~CReflectionWnd(){<strong>   <span class="cpp-keyword">if</span> (IsWindow()) DestroyWindow();</strong>}</pre>
 
<h2>Finishing Off The Deskband Toolbar </h2>
All that's left is for our deskband to create the toolbar window, have the host use the toolbar window, remove the unused IPersistStream implementation, implement IInputObject (for focus control) and do some code tweaking. So lets wrap this toolbar up. Open the StockBar.h header file. Remove the following lines of code that are in bold since we moved them to our stdafx.h for our other classes to also use. 
<pre lang="c++"><span class="cpp-preprocessor">#include "resource.h"       // main symbols</span><strong><span class="cpp-comment">//</span><span class="cpp-comment">// These are needed for IDeskBand</span><span class="cpp-comment">//</span><span class="cpp-preprocessor">#include <shlguid.h></span><span class="cpp-preprocessor">#include <shlobj.h></span></strong></pre>
Next remove the following line from the class delcaration. 
<pre lang="c++"><span class="cpp-keyword">public</span> IPersistStream,</pre>
The top of the class declaration should now look like this, 
<pre lang="c++"><span class="cpp-keyword">class</span> ATL_NO_VTABLE CStockBar :    <span class="cpp-keyword">public</span> CComObjectRootEx<CComSingleThreadModel>,   <span class="cpp-keyword">public</span> CComCoClass<CStockBar, &CLSID_StockBar>,   <span class="cpp-keyword">public</span> IDeskBand,   <span class="cpp-keyword">public</span> IObjectWithSite,   <span class="cpp-keyword">public</span> IDispatchImpl<IStockBar, &IID_IStockBar, &LIBID_MOTLEYFOOLLib>{</pre>
Next scroll down to the COM Map and remove the following two lines of code, 
<pre lang="c++">   COM_INTERFACE_ENTRY(IPersist)   COM_INTERFACE_ENTRY(IPersistStream)</pre>
Your COM Map should now look like this, 
<pre lang="c++">BEGIN_COM_MAP(CStockBar)   COM_INTERFACE_ENTRY(IStockBar)   COM_INTERFACE_ENTRY(IOleWindow)   COM_INTERFACE_ENTRY_IID(IID_IDockingWindow, IDockingWindow)   COM_INTERFACE_ENTRY(IObjectWithSite)   COM_INTERFACE_ENTRY_IID(IID_IDeskBand, IDeskBand)   COM_INTERFACE_ENTRY(IDispatch)END_COM_MAP()</pre>
Scroll down the header file further and remove the sections of function declarations for IPersist and IPersistStream, which includes the following lines. 
<pre lang="c++"><span class="cpp-comment">// IPersist</span><span class="cpp-keyword">public</span>:   STDMETHOD(GetClassID)(CLSID *pClassID);<span class="cpp-comment">// IPersistStream</span><span class="cpp-keyword">public</span>:   STDMETHOD(IsDirty)(<span class="cpp-keyword">void</span>);   STDMETHOD(Load)(IStream *pStm);   STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);   STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);</pre>
There should now be nothing related to IPersist or IPersistStream between the IDockingWindow and IStockBar function declaration sections. 
Now we need to remove the IPersist and IPersistStream function implementations from the StockBar.cpp source file. Find the GetClassID, IsDirty, Load, Save, and GetSizeMax function implementations and remove them from the file. They should be directly above the FocusChange Method we added earlier. 
Now we can start adding code to our deskband. Open the stockbar.h header file and add the include for the reflection window class as shown below in bold. 
<pre lang="c++"><span class="cpp-preprocessor">#include "resource.h"       // main symbols</span><strong>#include "ReflectionWnd.h"</strong></pre>
Next, find the protected section at the end of the file and replace the line 
<pre lang="c++">   HWND m_hWnd;</pre>
with 
<pre lang="c++">   CReflectionWnd m_ReflectWnd;</pre>
If you try to compile, you will find that it will be unsuccessful since we have removed m_hWnd and have not removed all occurances of m_hWnd from the class source file. We will replace all occurances with more appropriate code for our Reflection window and toolbar window. Open the StockBar.cpp source file, Remove the following line from the class constructor 
<pre lang="c++">   m_hWnd(NULL),</pre>
your class constructor should now look as follows with a SetBand call added, 
<pre lang="c++">CStockBar::CStockBar():    m_dwBandID(<span class="cpp-literal">0</span>),    m_dwViewMode(<span class="cpp-literal">0</span>),    m_bShow(FALSE),    m_bEnterHelpMode(FALSE),    m_hWndParent(NULL),    m_pSite(NULL){	m_ReflectWnd.GetToolBar().GetEditBox().SetBand(<span class="cpp-keyword">this</span>);}</pre>
Next, update the RegisterAndCreateWindow function by replacing the temporary m_hWnd construction with the Reflection Window construction. Your RegisterAndCreateWindow implementation should look as follows: 
<pre lang="c++">BOOL CStockBar::RegisterAndCreateWindow(){   RECT rect;   ::GetClientRect(m_hWndParent, &rect);   m_ReflectWnd.Create(m_hWndParent, rect, NULL, WS_CHILD);   <span class="cpp-comment">// The toolbar is the window that the host will be using so it is the window that is important.</span>   <span class="cpp-keyword">return</span> m_ReflectWnd.GetToolBar().IsWindow();}</pre>
As we scroll through the code, we should fix some other things. A toolbar has a default height of 22 so we need to update our GetBandInfo method so that all the y measurements are 22 not 20. We also want our Integral sizing to be non sizeable so we need to set the DBIM_INTEGRAL x and y values to 0. While we are at it, we should fix the title of our toolbar so it says "The Motley Fool". You'll find this constant defined near the top of the source file, update it now. 
We will now update the GetWindow call so that the toolbar window handle is returned and not the invalid m_hWnd variable. Update your GetWindow method so it looks as follows, 
<pre lang="c++">STDMETHODIMP CStockBar::GetWindow(HWND* phwnd){   HRESULT hr = S_OK;   <span class="cpp-keyword">if</span> (NULL == phwnd)   {      hr = E_INVALIDARG;   }   <span class="cpp-keyword">else</span>   {<strong>      *phwnd = m_ReflectWnd.GetToolBar().m_hWnd;</strong>   }   <span class="cpp-keyword">return</span> hr;}</pre>
Now we need to update teh CloseDW method so that it does not destory our window buy hide it. We do this much like the MFC CToolbar class does, the class destructor will destroy the window. Your CloseDW method should look as follows, 
<pre lang="c++">STDMETHODIMP CStockBar::CloseDW(<span class="cpp-keyword">unsigned</span> <span class="cpp-keyword">long</span> dwReserved){   ShowDW(FALSE);   <span class="cpp-keyword">return</span> S_OK;}</pre>
Working our way through our class implementation, we will update the next method that needs updating. Update the ShowDW class to show or hide the toolbar window which the host is using. Your ShowDW class should look as follows, 
<pre lang="c++">STDMETHODIMP CStockBar::ShowDW(BOOL fShow){   m_bShow = fShow;   m_ReflectWnd.GetToolBar().ShowWindow(m_bShow ? SW_SHOW : SW_HIDE);   <span class="cpp-keyword">return</span> S_OK;}</pre>
We are almost done modifying the CStockBar class we need to do one last bit of updating. We need to modify the SetSite implementation to release the browser window that the toolbar may be using if we have a IInputObjectSite object and we need to query the OleCommandTarget's ServiceProvider for the IWebBrowser2 interface which we will then set to our toolbar. The modified parts of the SetSite method implementation are below in bold. 
<div class="precollapse" id="premain58" style="WIDTH: 100%"><img id="preimg58" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="58" alt="" /><span id="precollapse58" style="MARGIN-BOTTOM: 0px; CURSOR: hand" preid="58"> Collapse</span></div>
<pre lang="c++" id="pre58" style="MARGIN-TOP: 0px">STDMETHODIMP CStockBar::SetSite(IUnknown* pUnkSite){<span class="cpp-comment">//If a site is being held, release it.</span>   <span class="cpp-keyword">if</span>(m_pSite)   {<strong>      m_ReflectWnd.GetToolBar().SetBrowser(NULL);</strong>      m_pSite->Release();      m_pSite = NULL;   }   <span class="cpp-comment">//If punkSite is not NULL, a new site is being set.</span>   <span class="cpp-keyword">if</span>(pUnkSite)   {      <span class="cpp-comment">//Get the parent window.</span>      IOleWindow  *pOleWindow = NULL;      m_hWndParent = NULL;      <span class="cpp-keyword">if</span>(SUCCEEDED(pUnkSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWindow)))      {         pOleWindow->GetWindow(&m_hWndParent);         pOleWindow->Release();      }      <span class="cpp-keyword">if</span>(!::IsWindow(m_hWndParent))         <span class="cpp-keyword">return</span> E_FAIL;      <span class="cpp-keyword">if</span>(!RegisterAndCreateWindow())         <span class="cpp-keyword">return</span> E_FAIL;      <span class="cpp-comment">//Get and keep the IInputObjectSite pointer.</span><strong>      <span class="cpp-keyword">if</span>(FAILED(pUnkSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&m_pSite)))      {         <span class="cpp-keyword">return</span> E_FAIL;      }        IWebBrowser2* s_pFrameWB = NULL;      IOleCommandTarget* pCmdTarget = NULL;      HRESULT hr = pUnkSite->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pCmdTarget);      <span class="cpp-keyword">if</span> (SUCCEEDED(hr))      {         IServiceProvider* pSP;         hr = pCmdTarget->QueryInterface(IID_IServiceProvider, (LPVOID*)&pSP);         pCmdTarget->Release();         <span class="cpp-keyword">if</span> (SUCCEEDED(hr))         {            hr = pSP->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&s_pFrameWB);            pSP->Release();            _ASSERT(s_pFrameWB);            m_ReflectWnd.GetToolBar().SetBrowser(s_pFrameWB);            s_pFrameWB->Release();         }      }</strong>   }   <span class="cpp-keyword">return</span> S_OK;}</pre>
If you try to compile and use the toolbar right now, it will function partially. Tabbing and input control will not work correctly since we have yet to implement IInputObject for our deskband. Let's do that now since it's the last bit of code we will write for our simple deskband. You may also notice that the Toolbars context menu and View|Toolbars menus still say CStockBar Class. we will fix this problem in the Finishing Touches section below. 
<h3>IInputObject Implementation </h3>
To get tabbing and input control to work correctly for any deskband is quite simple. You need but to implement IInputObject. The host will query our deskband to see if this interface is implemented and if it is will call the methods to see if we require input focus and let us also process messages from the user through the host. To do this, open the stockbar.h header file. To the stockbar class declaration add the line below in bold, 
<pre lang="c++"><span class="cpp-keyword">class</span> ATL_NO_VTABLE CStockBar :    <span class="cpp-keyword">public</span> CComObjectRootEx<CComSingleThreadModel>,   <span class="cpp-keyword">public</span> CComCoClass<CStockBar, &CLSID_StockBar>,   <span class="cpp-keyword">public</span> IDeskBand,   <span class="cpp-keyword">public</span> IObjectWithSite,<strong>   <span class="cpp-keyword">public</span> IInputObject,</strong>    <span class="cpp-keyword">public</span> IDispatchImpl<IStockBar, &IID_IStockBar, &LIBID_MOTLEYFOOLLib>{</pre>
Next scroll down to the COM Map and add an entry for IInputObject as shown below in bold, 
<pre lang="c++">BEGIN_COM_MAP(CStockBar)   COM_INTERFACE_ENTRY(IStockBar)<strong>   COM_INTERFACE_ENTRY(IInputObject)</strong>   COM_INTERFACE_ENTRY(IOleWindow)   COM_INTERFACE_ENTRY_IID(IID_IDockingWindow, IDockingWindow)   COM_INTERFACE_ENTRY(IObjectWithSite)   COM_INTERFACE_ENTRY_IID(IID_IDeskBand, IDeskBand)   COM_INTERFACE_ENTRY(IDispatch)END_COM_MAP()</pre>
Next add the following section of function declarations to your header file, I placed mine before the IStockBar section. 
<pre lang="c++"><span class="cpp-comment">// IInputObject</span><span class="cpp-keyword">public</span>:   STDMETHOD(HasFocusIO)(<span class="cpp-keyword">void</span>);   STDMETHOD(TranslateAcceleratorIO)(LPMSG lpMsg);   STDMETHOD(UIActivateIO)(BOOL fActivate, LPMSG lpMsg);</pre>
All that remains is to implement these three functions. Add the function implementations below to the end of the stockbar.cpp source file. 
<div class="precollapse" id="premain62" style="WIDTH: 100%"><img id="preimg62" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="62" alt="" /><span id="precollapse62" style="MARGIN-BOTTOM: 0px; CURSOR: hand" preid="62"> Collapse</span></div>
<pre lang="c++" id="pre62" style="MARGIN-TOP: 0px">STDMETHODIMP CStockBar::HasFocusIO(<span class="cpp-keyword">void</span>){   <span class="cpp-comment">// if any of the windows in our toolbar have focus then return S_OK else S_FALSE.</span>   <span class="cpp-keyword">if</span> (m_ReflectWnd.GetToolBar().m_hWnd == ::GetFocus())      <span class="cpp-keyword">return</span> S_OK;   <span class="cpp-keyword">if</span> (m_ReflectWnd.GetToolBar().GetEditBox().m_hWnd == ::GetFocus())     <span class="cpp-keyword">return</span> S_OK;   <span class="cpp-keyword">return</span> S_FALSE;}STDMETHODIMP CStockBar::TranslateAcceleratorIO(LPMSG lpMsg){   <span class="cpp-comment">// the only window that needs to translate messages is our edit box so forward them.</span>   <span class="cpp-keyword">return</span> m_ReflectWnd.GetToolBar().GetEditBox().TranslateAcceleratorIO(lpMsg);}STDMETHODIMP CStockBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg){   <span class="cpp-comment">// if our deskband is being activated then set focus to the edit box.</span>   <span class="cpp-keyword">if</span>(fActivate)   {      m_ReflectWnd.GetToolBar().GetEditBox().SetFocus();   }   <span class="cpp-keyword">return</span> S_OK;}</pre>
Our toolbar is functionaly done, compile, run it and see. It works as described and is fairly simple. Let's put some finishing UI touches on it for IE and our users to use. 
<h2>Finishing Touches </h2>
The are only 2 finishing touches to make, One is to fix the context menu text. The other is to add button support to the main IE toolbar. Let's do them in order. 
To fix the context menu text problem, open the StockBar.rgs project file and change all occurances of "StockBar Class" to "The Motley Fool Quotes". Compile it, run it, and see. While you only need to change one of them, it's nicer if they all match. 
Now let's add button support for our toolbar. Update the stockbar.rgs file contents by appending the text below to it's contents. 
<div class="precollapse" id="premain63" style="WIDTH: 100%"><img id="preimg63" style="CURSOR: hand" height="9" src="http://www.codeproject.com/images/minus.gif" width="9" preid="63" alt="" /><span id="precollapse63" style="MARGIN-BOTTOM: 0px; CURSOR: hand" preid="63"> Collapse</span></div>
<pre id="pre63" style="MARGIN-TOP: 0px">HKLM{   Software   {      Microsoft      {         <span class="cpp-string">'Internet Explorer'</span>         {            Extensions            {               ForceRemove	{A26ABCF0-1C8F-<span class="cpp-literal">46e7</span>-A67C-0489DC21B9CC} = s <span class="cpp-string">'The Motley Fool Quotes'</span>               {                  val BandClsid = s <span class="cpp-string">'{A6790AA5-C6C7-4BCF-A46D-0FDAC4EA90EB}'</span>                  val ButtonText = s <span class="cpp-string">'The Motley Fool'</span>                  val Clsid = s <span class="cpp-string">'{E0DD6CAB-2D10-11D2-8F1A-0000F87ABD16}'</span>                  val <span class="cpp-string">'Default Visible'</span> = s <span class="cpp-string">'Yes'</span>                  val <span class="cpp-string">'Hot Icon'</span> = s <span class="cpp-string">'%MODULE%,425'</span>                  val Icon = s <span class="cpp-string">'%MODULE%,425'</span>                  val MenuStatusBar = s <span class="cpp-string">'The Motley Fool Stock Quote Toolbar'</span>                  val MenuText = s <span class="cpp-string">'The Motley Fool'</span>               }            }         }      }   }}</pre>
The replace the 425 with the id from resource.h of IDI_MOTLEY. Also replace the BandClsid value with the GUID of our toolbar, the above values represent the source code for the article. Now compile the toolbar again. Then start IE and right click on the Standard Buttons toolbar, Select "Customize" from the context menu. Scroll down the Available toolbar buttons listbox and find "The Motley Fool" item, See Figure 12. Select it and click the Add button in the middle of the dialog. The item will move to the right as in Figure 13. Click the Close Button. You'll see the button added as shown in the before figure 14 and after figure 15. <center> 
Figure 12. CustomizeToolbar - Available Toolbar Buttons. </center><center> 
Figure 13. Customize Toolbar - Current Toolbar Buttons. </center><center> 
Figure 14. IE Standard Buttons - Before. </center><center> 
Figure 15. IE Standard Buttons - After. </center>
<h2>Conclusion </h2>
While this tutorial is long hopefully the explaination was clear. From writing this tutorial it is easy to see that the RBDeskband ATL Object Wizard has some room for improvement but provided enough of a base for us to develop our simple example. In the end you can see that the toolbar we created is much like the Address bar. The differences lie in how MS implemented theirs versus how I implemented mine. As always feedback is welcome. Enjoy. <!-- Article Ends --><script src="/script/togglePre.js" type="text/javascript"></script>
<h2>About Erik Thompson</h2>
<div style="OVERFLOW: hidden">
<table border="0">
<tbody>
<tr valign="top">
<td class="smallText" nowrap="nowrap">
            
             Site Builder</td>
<td class="smallText">Erik lives in Redmond, Washington. He works as a Senior Software Engineer specializing in C++, COM, ATL and the middle-tier and now .NET. When he isn't coding for work, he can be found trying to extend Internet Explorer with yet another Desk band or simplifying his development process with ATL Object Wizards.
            
            He spends his free time snowboarding, mountain biking, reading, dining out at those hidden finds.
<p class="smallText">Click <a href="http://www.codeproject.com/script/profile/whos_who.asp?vt=arts&id=78">here</a> to view Erik Thompson's online profile.            </td>        </tr>    </tbody></table></div>

<table cellpadding="4" width="100%" border="0">
<tbody>
<tr valign="top">
<td width="100%">
<h2>Other popular ATL articles:</h2>
<ul>
<li><a href="http://www.codeproject.com/atl/com_atl.asp">Beginner's Tutorial: COM/ATL Simple Project</a>
<div class="smallText">The purpose of this tutorial is to give you an idea on how to create a COM Server using ATL, and then being able to call the server from both a Visual C++ and Visual Basic program.</div>                </li>
<li><a href="http://www.codeproject.com/atl/atl_underthehood_.asp">ATL Under the Hood - Part 1</a>
<div class="smallText">In this series of tutorials I am going to discuss some of the inner workings of ATL and the techniques that ATL uses.</div>                </li>
<li><a href="http://www.codeproject.com/atl/MouseGestures.asp">Mouse Gestures for Internet Explorer</a>
<div class="smallText">Adding mouse gesture recognition to Internet Explorer.</div>                </li>
<li><a href="http://www.codeproject.com/atl/udtdemo.asp">Using User Defined Types in COM & ATL</a>
<div class="smallText">A Step by Step tutorial on SAFEARRAYs and UDTs in COM</div>                </li>            </ul>            </td>        </tr>    </tbody></table>

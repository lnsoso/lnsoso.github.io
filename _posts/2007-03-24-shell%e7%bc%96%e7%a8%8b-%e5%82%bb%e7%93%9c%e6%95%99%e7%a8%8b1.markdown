---
layout: post
title: Shell编程 - 傻瓜教程1
author: Alvin
date: !binary |-
  MjAwNy0wMy0yNCAyMTozOTowOCArMDgwMA==
date_gmt: !binary |-
  MjAwNy0wMy0yNCAxMzozOTowOCArMDgwMA==
---
<div class="postTitle"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">    外壳扩展</span><span lang="EN-US">(Shell Extention)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是一个能向</span><span lang="EN-US">Windows</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">外壳</span><span lang="EN-US">(</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">资源管理器</span><span lang="EN-US">)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">添加一些功能的</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">对象。这有很多的内容，但是却很少有关于它们的易懂的文档告诉我们如何去编写这些外壳</span><span lang="EN-US">(Shell)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">程序。如果你想做对外壳很深入的了解，我极力向你推荐</span><span lang="EN-US">Dino Esposito </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的非常好的一本书《</span><cite><span lang="EN-US">Visual C++ Windows Shell Programming</span></cite><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">》。但是对于那些没有这本书并且仅仅关心如何去编写外壳扩展的人，我写的一指南将会令你非常惊讶，如果并非如此的话也能给你理解如何编写外壳扩展提供很好的帮助。要阅读这一指南，确保你对</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">要相当熟悉。</span> </div>
<div class="postText">
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">第一部分包括了对外壳扩展的概要的介绍，并提供了一个上下文菜单扩展的例程来使你对以后的部分中充满兴趣。</span>
<h2 style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">什么是<em>外壳扩展</em>呢？</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">这有两部分，外壳和扩展</span><span lang="EN-US">(<em>extension</em>)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。外壳指的是资源管理器</span><span lang="EN-US">(Explorer)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，而扩展是指当一个预订的事件（如：右键单击一个</span><span lang="EN-US">.doc</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文档）发生时，被资源管理器调用的你写的代码。所以以个外壳扩展是一个向资源管理器添加特色的</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">对象。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">一个外壳扩展是一个进程中服务器，它实现了一些与资源管理器通信的借口。而在我看来，</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是快速实现一个扩展并使它运行的最简单的方法，因为你不用为一遍又一遍的写</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryInterface()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">AddRef()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">而大伤脑筋。而且在</span><span lang="EN-US">Windows NT/2000</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下调试扩展也变得更为容易。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">有很多种的扩展，每种扩展在不同的事件发生时被调用。下面是一些比较通用的类型和它们被调用的情况：</span>
<table style="WIDTH: 100%; mso-cellspacing: 1.5pt" cellpadding="0" width="100%" border="1">
<tbody>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p style="TEXT-ALIGN: center" align="center"><strong><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">类型</span><span lang="EN-US"> <o:p></o:p></span></strong>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p style="TEXT-ALIGN: center" align="center"><strong><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">什么时候被调用</span><span lang="EN-US"> <o:p></o:p></span></strong>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p style="TEXT-ALIGN: center" align="center"><strong><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">可以做什么</span><span lang="EN-US"><o:p></o:p></span></strong>            </td>        </tr>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">上下文菜单</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">用户在文件或目录右键单击时。在外壳扩展</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">4.71</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">版本以上，在目录窗口的背景上右键单击也将被调用。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">向上下文菜单添加项目。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>        </tr>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">属性单</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文件的属性单被显示时。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">向属性单添加一个属性页。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>        </tr>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">拖扔</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">用户右键拖动项目并把它扔在一个目录窗口活着桌面上时。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">添加项目至上下文菜单。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>        </tr>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">扔</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">用户拖一个项目并把它扔到一个文件上时。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">任何你想做的事。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>        </tr>
<tr>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">查询信息</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">(</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">外壳版本</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">4.71+)<span style="COLOR: black"><o:p></o:p></span></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 33%; PADDING-TOP: 0.75pt" width="33%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">用户鼠标在一个文件或像我的电脑一样的其他外壳对象上悬停时。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>
<td style="PADDING-RIGHT: 0.75pt; PADDING-LEFT: 0.75pt; PADDING-BOTTOM: 0.75pt; WIDTH: 34%; PADDING-TOP: 0.75pt" width="34%">
<p class="MsoNormal"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">返回一个资源管理器在工具条提示上的字符串。</span><span lang="EN-US" style="FONT-SIZE: 10pt; COLOR: black; FONT-FAMILY: Verdana"><o:p></o:p></span>            </td>        </tr>    </tbody></table>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">到现在为止你可能为什么一个扩展看起来想在资源管理器里。如果你安装了</span><span lang="EN-US">WinZip</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">（有谁没有吗？），它就包括了许多种的外壳扩展，其中一个就是上下文句柄。下面世</span><span lang="EN-US">WinZip 8 </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">为了压缩文件添加到上下文菜单的截图：</span>
<p style="TEXT-INDENT: 21pt"><span lang="EN-US">WinZip</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">包含了添加菜单项目的代码，并提供敏感帮助（显示在资源管理器状态条的文本），并在用户选择</span><span lang="EN-US">WinZip</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">命令之一时起作用。</span>
<p style="TEXT-INDENT: 21pt"><span lang="EN-US">WinZip</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">还包含了拖和扔的句柄。这个类型和上下文菜单扩展非常类似，但是它仅仅在用户通过鼠标右键拖动一个文件时才被调用。下面是</span><span lang="EN-US">WinZip</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的拖扔句柄如何添加上下文菜单：</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">还有很多种其他类型（微软一直往新版本的</span><span lang="EN-US">Windows</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">里添加更多内容）。到现在，我们已经看到了上下文菜单扩展，因为它非常容易编写，我们将很容易的看到它的结果（很快就能满意）。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在我们开始编码以前，有一些提示，它将使我们做起来更加容易。当你促成一个外壳扩展被资源管理器调用的时候，它将在内存中呆上一小会儿，从而使它不能立即被重建</span><span lang="EN-US">(rebuild)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。为了使资源管理器更加频繁的卸载这些扩展，创建这个注册表键：</span>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-SIZE: 9pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\AlwaysUnloadDLL</span></code><span lang="EN-US" style="FONT-SIZE: 9pt; mso-bidi-font-size: 10.0pt"><o:p></o:p></span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">并把它的默认值设为</span><span lang="EN-US">”1”</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。在</span><span lang="EN-US">Windows 9x</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">系列中，这是最好的方法。在</span><span lang="EN-US">NT/2000</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，到如下的键：</span>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-SIZE: 9pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer</span></code><span lang="EN-US" style="FONT-SIZE: 9pt; mso-bidi-font-size: 10.0pt"><o:p></o:p></span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">创建一个叫做</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">DesktopProcess</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的双字节值，使它的值为</span><span lang="EN-US">1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。这使得桌面和任务栏运行在一个进程中，后发的资源管理器运行在它自己的进程里。这就意味着你可以使用一个单独的资源管理器窗口来调试，并且当你关掉它的时候，你的</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">也会自动的被卸载，避免了该文件仍然在使用得问题。要使得你的注册表修改生效的话，你必须注销并且重新登录。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我将稍晚一些解释如何在</span><span lang="EN-US">Win 9x</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下进行调试。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">开始一个上下文菜单扩展</span><span lang="EN-US"> &ndash; </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">它能做什么</span><span lang="EN-US">?</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">让我们开始简单的做一个扩展，它仅仅弹出一个消息框表示它已经在工作了。我们将对扩展名为</span><span lang="EN-US">.txt</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的文件设置一个钩子，这样当用户右键单击一个文本文件的时候，我们的扩展就能被调用了。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">使用</span><span lang="EN-US">AppWizard </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">开始</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">好了，现在是我们开始的时候了。那是什么？我还没有告诉你如何使用神秘的外壳扩展接口？不要担心，我将在接下来的过程中为你解释。我发现如果一个概念被解释，有一个例子更容易明白，通过例子代码你很快就能理解。我将会先解释任何东西，然后给出代码，但是我发现还是不容易吸收。总之，启动你的</span><span lang="EN-US">MSVC</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">吧，我们要开始了。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">运行</span><span lang="EN-US">AppWizard </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，做一个新的</span><span lang="EN-US">ATL COM wizard app</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。我们叫它</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleExt</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。在向导中保持所有默认选项，单击完成。我们现在就有了一个空的将会生成</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">项目，但是我们必须添加自己的外壳扩展</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">对象。在</span><span lang="EN-US">ClassView</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">树中，右键单击</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleExt classes</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">项，选择</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">New ATL Object</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在</span><span lang="EN-US">ATL Object </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">向导，第一面板已经选择了</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">Simple Object</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，只要单击下一步就行了。在第二面板中，在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">Short Name</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">编辑控件中输入</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleShlExt</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，然后单击确定（面板中的其它的编辑框将会自动完成）。这就创建了一个类名为</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">CSimpleShlExt</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的类，它包含了实现一个</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">对象的基本代码。我们将向这个类添加我们的代码。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">初始化接口</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">当我们的外壳扩展被装载的时候，资源管理器调用我们的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryInterface()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数获取一个指向</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IShellExtInit</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接口的指针。这个接口只有一个方法，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">Initialize()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，它的原型如下：</span>
<pre><span lang="EN-US">HRESULT IShellExtInit::Initialize (</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPCITEMIDLIST pidlFolder,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPDATAOBJECT pDataObj,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">  </span><span style="mso-spacerun: yes">  </span>HKEY hProgID );</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">资源管理器使用这个方法给我们不同的信息。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pidlFolder</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是包含有正在被作用的文件的文件夹的</span><span lang="EN-US">PIDL(PIDL[<strong>p</strong>ointer to an <strong>ID</strong> <strong>l</strong>ist]</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是唯一标志外壳中任一对象（无论是否是文件系统对象）的数据结构。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pDataObj</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是一个</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IDataObject</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接口指针，通过它我们可以获得被作用的文件的文件名。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">hProgID</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是一个打开的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKEY</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，通过它我们可以访问包含有我们的</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">注册数据的注册表键。在这个简单的扩展中，我们只需要用到</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pDataObj</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">参数。</span>
<span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">添加这个接口方法到我们的</span><span lang="EN-US">COM </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">对象中，先打开</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleShlExt.h</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文件，并添加如下用红色书写的代码行：</span>
<pre><span lang="EN-US" style="COLOR: red">#include <shlobj.h><o:p></o:p></span></pre>
<pre><span lang="EN-US" style="COLOR: red">#include <comdef.h></span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US">class ATL_NO_VTABLE CSimpleShlExt : </span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public CComObjectRootEx<CComSingleThreadModel>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public CComCoClass<CSimpleShlExt, &CLSID_SimpleShlExt>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public IDispatchImpl<ISimpleShlExt, &IID_ISimpleShlExt, &LIBID_SIMPLEEXTLib>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span></span><span lang="EN-US" style="COLOR: red">public IShellExtInit</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US">BEGIN_COM_MAP(CSimpleShlExt)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>COM_INTERFACE_ENTRY(ISimpleShlExt)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>COM_INTERFACE_ENTRY(IDispatch)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span></span><span lang="EN-US" style="COLOR: red">COM_INTERFACE_ENTRY(IShellExtInit)</span></pre>
<pre><span lang="EN-US">END_COM_MAP()</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">这个</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">COM_MAP</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是说明了</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">如何实现它的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryInterface()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。这个列表告诉</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">其他使用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryInterface()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的程序可以从我们这儿获得什么。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接着，在类的声明当中，添加</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">Initialize()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数。此外，我们还需要一个保存文件名的变量：</span>
<pre><span lang="EN-US">protected:</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>TCHAR m_szFile [MAX_PATH];</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US">public:</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// IShellExtInit</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>STDMETHOD(Initialize)(LPCITEMIDLIST, LPDATAOBJECT, HKEY);</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接下来，在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleShlExt.cpp</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文件中，添加该函数的定义：</span>
<pre><span lang="EN-US">HRESULT CSimpleShlExt::Initialize ( </span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPCITEMIDLIST pidlFolder,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPDATAOBJECT pDataObj,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>HKEY hProgID )</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们所要做的就是获得被右键单击的文件的文件名，并把它显示在一个消息框中。如果有很多个文件被选中，你可以通过</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pDataObj</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接口指针访问它们。但是为了保持该例子的简单性，我只要获得第一个文件的文件名。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文件名被保存为与你使用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">WS_EX_ACCEPTFILES</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">样式拖和扔一个文件到窗口时用到的一个相同的格式。那就意味着，我们获得文件名使用了相同的</span><span lang="EN-US">API:</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'"> DragQueryFile()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。我们通过获得包含在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IDataObject</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">中的数据的句柄开始这个函数：</span>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US">FORMATETC fmt = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };</span></pre>
<pre><span lang="EN-US">STGMEDIUM stg = { TYMED_HGLOBAL };</span></pre>
<pre><span lang="EN-US">HDROP<span style="mso-spacerun: yes">     </span>hDrop;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Look for CF_HDROP data in the data object.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( FAILED( pDataObj->GetData ( &fmt, &stg )))</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>// Nope! Return an "invalid argument" error back to Explorer.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Get a pointer to the actual data.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>hDrop = (HDROP) GlobalLock ( stg.hGlobal );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Make sure it worked.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( NULL == hDrop )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">要注意，错误检查是极其重要的，尤其是指针。因为我们的扩展运行在资源管理器的进程空间当中，如果我们的程序毁坏的话，同样会让资源管理器也毁坏的。在</span><span lang="EN-US">Win 9x</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下，这可能就意味着重新启动。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">现在，我们有了一个</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HDROP</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">句柄，我们可以获得我们需要的文件名了。</span>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Sanity check &ndash; make sure there is at least one filename.</span></pre>
<pre><span lang="EN-US">UINT uNumFiles = DragQueryFile ( hDrop, 0xFFFFFFFF, NULL, 0 );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"> <span style="mso-spacerun: yes">   </span>if ( 0 == uNumFiles )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>GlobalUnlock ( stg.hGlobal );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>ReleaseStgMedium ( &stg );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US">HRESULT hr = S_OK;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Get the name of the first file and store it in our member variable m_szFile.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( 0 == DragQueryFile ( hDrop, 0, m_szFile, MAX_PATH ))</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>hr = E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>GlobalUnlock ( stg.hGlobal );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>ReleaseStgMedium ( &stg );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>return hr;</span></pre>
<pre><span lang="EN-US">}</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">如果我们返回</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">E_INVALIDAR</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，在右键单击事件发生时，资源管理器将不会再调用我们的扩展。如果我们返回</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">S_OK</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，那么资源管理器将会再次调用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryInterface()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">来获得我们将要添加的另一个接口指针：</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和上下文菜单交互的接口</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">一旦资源管理器初始化了我们的扩展，它将会调用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的方法让我们添加菜单项目、敏感帮助并完成用户的选择。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">向我们的扩展中添加</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接口和添加</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IShellExtInit</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">相类似。打开</span><span lang="EN-US">SimpleShlExt.h</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">并添加一下红颜色的代码：</span>
<pre><span lang="EN-US">class ATL_NO_VTABLE CSimpleShlExt : </span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public CComObjectRootEx<CComSingleThreadModel>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public CComCoClass<CSimpleShlExt, &CLSID_SimpleShlExt>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public IDispatchImpl<ISimpleShlExt, &IID_ISimpleShlExt, &LIBID_SIMPLEEXTLib>,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>public IShellExtInit,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span></span><span lang="EN-US" style="COLOR: red">public IContextMenu</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US">BEGIN_COM_MAP(CSimpleShlExt)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>COM_INTERFACE_ENTRY(ISimpleShlExt)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>COM_INTERFACE_ENTRY(IDispatch)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>COM_INTERFACE_ENTRY(IShellExtInit)</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span></span><span lang="EN-US" style="COLOR: red">COM_INTERFACE_ENTRY(IContextMenu)</span></pre>
<pre><span lang="EN-US">END_COM_MAP()</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接着添加</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">方法的原型：</span>
<pre><span lang="EN-US">public:</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// IContextMenu</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>STDMETHOD(GetCommandString)(UINT, UINT, UINT*, LPSTR, UINT);</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO);</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>STDMETHOD(QueryContextMenu)(HMENU, UINT, UINT, UINT, UINT);</span></pre>
<h3><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial">更改上下文菜单</span></h3>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">有</span><span lang="EN-US">3</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">个方法。第一个，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryContextMenu()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，让我们更改菜单。它的原型为：</span>
<pre><span lang="EN-US">HRESULT IContextMenu::QueryContextMenu (</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>HMENU hmenu,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uMenuIndex, </span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uidFirstCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uidLastCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uFlags );</span></pre>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">hmenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是上下文菜单的句柄。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uMenuIndex</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是我们开始添加我们的菜单项目的开始位置。</span> <code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uidFirstCmd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span> <code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uidLastCmd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是我们可以给菜单项目使用的命令</span><span lang="EN-US">ID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">值的范围。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uFlags</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">指出为什么资源管理器正在调用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryContextMenu()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，这我们将在以后看到。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">有关它的返回值你将会得到不同的答案，如果你问不同的人的话。</span><span lang="EN-US">Dino Esposito </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的书上说它使被</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryContextMenu()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">添加的菜单项目的号码。</span><span lang="EN-US">MSDN</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">上关于</span><span lang="EN-US">VC 6</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">部分说它是最后一个被添加的菜单项目的命令</span><span lang="EN-US">ID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">加上</span><span lang="EN-US">1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。最新的</span><span lang="EN-US">MSDN</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文档有如下说明：</span>
<p style="MARGIN-LEFT: 36pt; MARGIN-RIGHT: 36pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">设置代码的值</span><span lang="EN-US">[</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">由</span><span lang="EN-US">HRESULT</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">返回的</span><span lang="EN-US">]</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">为被分配的最大的命令</span><span lang="EN-US">ID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">偏移加上</span><span lang="EN-US">1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。例如，假定</span><span lang="EN-US">idCmdFirst</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">被设置为</span><span lang="EN-US">5</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，你添加了</span><span lang="EN-US">3</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">个菜单项目分别使用命令</span><span lang="EN-US">ID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">为</span><span lang="EN-US">5</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">、</span><span lang="EN-US">7</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><span lang="EN-US">8</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。它的返回值将是</span><span lang="EN-US">MAKE_HRESULT(SEVERITY_SUCCESS, 0, 8 - 5 + 1)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span><span lang="EN-US"> </span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">到我现在所写的所有代码中，我接受了</span><span lang="EN-US">Dino</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的解释，这样工作的很好。事实上，他的制作返回值的方法和在线</span><span lang="EN-US">MSDN</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的方法是相同的，在你使用</span><span lang="EN-US">uidFirstCmd</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">开始添加你的菜单项目时开始计数，每添加一个增加</span><span lang="EN-US">1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span><span lang="EN-US"> </span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们的简单的扩展将仅仅添加一个菜单项目，所以</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">QueryContextMenu()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数相当简单：</span>
<pre><span lang="EN-US">HRESULT CSimpleShlExt::QueryContextMenu (</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>HMENU hmenu,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uMenuIndex, </span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uidFirstCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uidLastCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uFlags )</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// If the flags include CMF_DEFAULTONLY then we shouldn't do anything.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( uFlags & CMF_DEFAULTONLY )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return MAKE_HRESULT ( SEVERITY_SUCCESS, FACILITY_NULL, 0 );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>InsertMenu ( hmenu, uMenuIndex, MF_BYPOSITION, uidFirstCmd, _T("SimpleShlExt Test Item") );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>return MAKE_HRESULT ( SEVERITY_SUCCESS, FACILITY_NULL, 1 );</span></pre>
<pre><span lang="EN-US">}</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们首先要做的就是检查</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uFlags</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。你可以在</span><span lang="EN-US">MSDN</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">查询所有的标志列表，但是对于上下文菜单扩展来说，只有一样是重要的：</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">CMF_DEFAULTONLY</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。这个标志告诉名字空间扩展仅仅添加默认菜单项目。如果这个标志在的话，外壳扩展将不会添加任何菜单项目。这就是为什么当</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">CMF_DEFAULTONLY</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">存在的时候我们立即返回</span><span lang="EN-US">0</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的原因。如果该标志不存在，我们更改菜单（使用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">hmenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">句柄），然后返回</span><span lang="EN-US">1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">告诉外壳我们添加了一个菜单项目。</span>
<h3><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial">在状态条显示敏感帮助</span></h3>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">中下一个可以调用的方法是</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。如果用户在资源管理器窗口中右键单击了一个文本文件的时候，或者选中一个文本文件，然后单击“文件”菜单，状态条上将显示敏感帮助。我们的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数将会返回一个让资源管理器显示得字符串。</span>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数原型如下：</span>
<pre><span lang="EN-US">HRESULT IContextMenu::GetCommandString (</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT idCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT uFlags,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT *pwReserved,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPSTR pszName,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT cchMax );</span></pre>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">idCmd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是一个基于</span><span lang="EN-US">0</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的指明哪个菜单项目被选中的数。因为我们仅仅添加了一个菜单项，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">idCmd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">将总是为</span><span lang="EN-US">0</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。但是如果我们添加了，我是说，</span><span lang="EN-US">3</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">个的话，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">idCmd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">将会是</span><span lang="EN-US">0,1</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">或者</span><span lang="EN-US">2</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uFlags</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是另一个标志组。我将会在后面进行描述。我们可以忽略</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pwReserved</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">pszName</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是一个指向一个被外壳所拥有的缓存的指针，该缓存保存被显示的帮助字符串。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">cchMax</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是缓存的大小。返回值是</span><span lang="EN-US">HRESULT</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">常量，例如</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">S_OK</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">或</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">E_FAIL</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">同样能被用来获得菜单项的“动词”。“动词”是一个标志作用于文件的动作的字符串，它是独立于语言的。有关</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ShellExecute()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的文档作了更多的说明，有关“动词”的主题更适合在另一篇文章说明，这儿简要说明的是列在注册表中的动词（比如说</span><span lang="EN-US">”open”</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><span lang="EN-US">”print”</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">），或者那些有上下文菜单扩展动态创建的“动词”。这使得在外壳扩展中实现的行为可以被</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ShellExecute()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">调用。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">总之，我提及所有这些的原因是我们不得不确定为什么</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">被调用。如果资源管理器需要一个敏感帮助字符串的时候，我们就提供。如果资源管理器请求一个“动词”的话，我们将忽略它。这是</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uFlags</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">起作用的地方。如果</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">uFlags</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GCS_HELPTEXT</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的位被设置的话，那么资源管理器将请求敏感帮助。附加的，如果</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GCS_UNICODE</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">位被设置，我们必须返回一个</span><span lang="EN-US">Unicode</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">字符串。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">GetCommandString()</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的代码看起来应该像下面这样：</span>
<pre><span lang="EN-US">#include <atlconv.h><span style="mso-spacerun: yes">  </span>// for ATL string conversion macros</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US">HRESULT CSimpleShlExt::GetCommandString (</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>idCmd,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>uFlags,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT* pwReserved,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>LPSTR pszName,</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>UINT<span style="mso-spacerun: yes">  </span>cchMax )</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>USES_CONVERSION;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Check idCmd, it must be 0 since we have only one menu item.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( 0 != idCmd )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// If Explorer is asking for a help string, copy our string into the</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// supplied buffer.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( uFlags & GCS_HELPTEXT )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>LPCTSTR szText = _T("This is the simple shell extension's help");</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>if ( uFlags & GCS_UNICODE )</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">     </span><span style="mso-spacerun: yes">       </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>// We need to cast pszName to a Unicode string, and then use the</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>// Unicode string copy API.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>lstrcpynW ( (LPWSTR) pszName, T2CW(szText), cchMax );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>}</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>else</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>// Use the ANSI string copy API to return the help string.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>lstrcpynA ( pszName, T2CA(szText), cchMax );</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return S_OK;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US">}</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">没什么奇特的；我只是把字符串编码并且把它转换为合适的字符集。如果你以前从来都没有使用过</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">变换宏，你干脆先看看它们，因为这将我使更容易理解传递一个</span><span lang="EN-US">Unicode</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">字符串到</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">方法和</span><span lang="EN-US">OLE</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数中。在上面的代码中，我使用了</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">T2CW</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">T2CA</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">分别将</span><span lang="EN-US">TCHAR</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">字符串转换为</span><span lang="EN-US">Unicode</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><span lang="EN-US">ANSI</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。在函数头部的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">USES_CONVERSION</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">宏声明了一个变换宏使用的局部变量。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">一个需要注意的重要事项是</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">lstrcpyn()</span></code><span lang="EN-US">API</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数保证了目标字符串是以</span><span lang="EN-US">null</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">结束的。这是它和</span><span lang="EN-US">CRT</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">strncpy()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的不同之处。如果源字符串的长度大于或等于</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">cchMax</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">时，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'"> strncpy()</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">并不添加结束符</span><span lang="EN-US">null</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。我建议你总是使用</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">lstrcpyn()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，这样你就不用不得不在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">strncpy()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">之后添加检查来保证字符串是</span><span lang="EN-US">null</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">结束的。</span>
<h3><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Arial; mso-hansi-font-family: Arial">执行用户的选择</span></h3>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">最后一个</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">IContextMenu</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">方法是</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">InvokeCommand()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。这个方法将在用户单击我们添加的那个菜单项目时被调用。它的原型如下：</span>
<pre><span lang="EN-US">HRESULT IContextMenu::InvokeCommand ( LPCMINVOKECOMMANDINFO pCmdInfo );</span></pre>
<p style="TEXT-INDENT: 21pt"><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">CMINVOKECOMMANDINFO</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">结构里有很多的信息，但是根据我们现在的意图，我们只需要关心</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">lpVerb</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">hwnd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">lpVerb</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">有双重的任务&mdash;&mdash;它既可以是被调用的“动词”的名称，也可以是一个用以告诉我们哪个菜单项被选中地索引。</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">hwnd</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是资源管理器窗口的句柄，在那儿，用户调用了我们的扩展。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们检查</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">lpVerb</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，因为我们只添加了一个菜单项，所以如果它为</span><span lang="EN-US">0</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，则我们的菜单被点击了。我能想到的最简单的事就是弹出一个消息框，所以我们就这么做。这个消息框显示了选中的文件的文件名，证明它的确是在工作。</span>
<pre><span lang="EN-US">HRESULT CSimpleShlExt::InvokeCommand ( LPCMINVOKECOMMANDINFO pCmdInfo )</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// If lpVerb really points to a string, ignore this function call and bail out.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>if ( 0 != HIWORD( pCmdInfo->lpVerb ))</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>// Get the command index - the only valid one is 0.</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>switch ( LOWORD( pCmdInfo->lpVerb ))</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>case 0:</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>TCHAR szMsg [MAX_PATH + 32];</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>wsprintf ( szMsg, _T("The selected file was:\n\n%s"), m_szFile );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>MessageBox ( pCmdInfo->hwnd, szMsg, _T("SimpleShlExt"),</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">                         </span>MB_ICONINFORMATION );</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>return S_OK;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>}</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>break;</span></pre>
<pre><span lang="EN-US"> <o:p></o:p></span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>default:</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>return E_INVALIDARG;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>break;</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US">}</span></pre>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">注册外壳扩展</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">到现在为止，我们已经实现了我们所有的</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接口。但是……如何使资源管理器使用我们的扩展呢？</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">自动生成了注册我们的</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">为一个</span><span lang="EN-US">COM</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">服务器的代码，但是它仅仅是让其它程序来使用我们的</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。为了告诉资源管理器我们的扩展存在，我们必须在保持文本文件的注册表键下注册它：</span>
<code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKEY_CLASSES_ROOT\txtfile</span></code>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在那个键下面，一个叫做</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ShellEx</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的键保存了一个对于文本文件将被调用的外壳扩展列表。在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ShellEx</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下，</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ContextMenuHandlers</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">键保存了一个上下文菜单扩展的列表。每一个扩展在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ContextMenuHandlers</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下创建一个字键，并把他的默认值设置为它的</span><span lang="EN-US">GUID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。所以，为我们的扩展，我们创建如下键：</span>
<code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKEY_CLASSES_ROOT\txtfile\ShellEx\ContextMenuHandlers\SimpleShlExt</span></code>
<span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">并把它的默认值设置为我们的</span><span lang="EN-US">GUID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">：</span>
<span lang="EN-US">"{5E2121EE-0300-11D4-8D3B-444553540000}"</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">然而，你不用自己做这件事。如果你在</span><span lang="EN-US">FileView</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">页查看你得文件列表时，你会发现</span><span lang="EN-US">SimpleShlExt.rgs</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。这是一个由</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">解析的文本文件，它告诉</span><span lang="EN-US">ATL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">当这个服务器被注册时该添加什么键，当被反注册时又该删除什么键。下面我们指定了要添加的注册表入口：</span>
<pre><span lang="EN-US">HKCR</span></pre>
<pre><span lang="EN-US">{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>NoRemove txtfile</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>NoRemove ShellEx</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>NoRemove ContextMenuHandlers</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">            </span>{</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">                </span>ForceRemove SimpleShlExt = s '{5E2121EE-0300-11D4-8D3B-444553540000}'</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">           </span><span style="mso-spacerun: yes"> </span>}</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">        </span>}</span></pre>
<pre><span lang="EN-US"><span style="mso-spacerun: yes">    </span>}</span></pre>
<pre><span lang="EN-US">}</span></pre>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">它以</span><span lang="EN-US">"HKCR"</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">&mdash;&mdash;</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKEY_CLASSES_ROOT</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的缩写&mdash;&mdash;开头，每一行是注册表键名称。关键词</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">NoRemove</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">意味着当该服务器被反注册时该键不能被删除。最后一行有点复杂。关键词</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">ForceRemove</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">意思是如果该键存在，那么在该键被写之前先删除它。这一行剩下的部分指定了一个将被保存在</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">SimpleShlExt</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">键的默认值中的字符串</span><span lang="EN-US">(</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">那就是</span><span lang="EN-US">”s”</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的意思</span><span lang="EN-US">)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。</span>
<p style="TEXT-INDENT: 18pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在这儿，我需要说明一点。我们注册扩展时的键是</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKCR\txtfile</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。然而，这个名称</span><span lang="EN-US">"txtfile" </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">并不是一个永久的或预先知道的。如果你查看一下</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">HKCR\.txt</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，那个键的默认值是这个名称被保存的地方。这就两个侧面效果：</span>
<ul type="disc">
<li class="MsoNormal" style="mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">我们将不能可靠的使用</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">RGS</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">脚本，因为</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">"txtfile"</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">可能不是正确的键名。</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana"> <o:p></o:p></span></li>
<li class="MsoNormal" style="mso-margin-top-alt: auto; mso-margin-bottom-alt: auto; tab-stops: list 36.0pt; mso-list: l0 level1 lfo1"><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">其他的一些文本编辑器可能被安装，它们同</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana">.TXT</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">文件相关联。如果它们改变了</span><span style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana"> </span><code><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: 'Courier New'">HKCR\.txt</span></code><span style="FONT-SIZE: 10pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">键的默认值，所有存在的外壳扩展都将会停止工作。</span><span lang="EN-US" style="FONT-SIZE: 10pt; FONT-FAMILY: Verdana"> <o:p></o:p></span></li></ul>
<p style="TEXT-INDENT: 18pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">看起来，这的确是我设计的缺陷。我想微软也在考虑同样的事，因为最近创建的扩展，像</span><span lang="EN-US">QueryInfo</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">扩展，是在</span><span lang="EN-US">.txt</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">键下注册的。</span>
<p style="TEXT-INDENT: 18pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">好了，说明到这儿。有一个最终的注册细节。在</span><span lang="EN-US">Win NT/2000</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下，我们必须自己将我们的扩展方到一个“被认可的”扩展列表当中。如果我们不这么做的话，那些非管理员用户将不会壮在我们的扩展。这个列表被保存在：</span>
<code><span lang="EN-US" style="FONT-SIZE: 9pt; FONT-FAMILY: 'Courier New'; mso-bidi-font-size: 10.0pt">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved</span></code><span lang="EN-US" style="FONT-SIZE: 9pt; mso-bidi-font-size: 10.0pt"><o:p></o:p></span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在这个键下，我们创建一个字符串值它的名称是我们的</span><span lang="EN-US">GUID</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。字符串的内容可以是任何东西。做这些事情的代码在我们的</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">DllRegisterServer()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">和</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">DllUnregisterServer()</span></code><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">函数当中。我并不想把这些呆马列在这儿，因为这只是简单的注册表访问。你可以从本文的例子项目当中找到它们。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">调试外壳扩展</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">最终，你写成了这个相当不容易的扩展，然后你将会调试它。打开你的项目设置</span><span lang="EN-US">(Project->Settings)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，到</span><span lang="EN-US">Debug</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">栏，在</span><span lang="EN-US">"Executable for debug session"</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">编辑框中输入资源管理器的全路径，例如：</span><span lang="EN-US">"C:\windows\explorer.exe"</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">。如果你使用的是</span><span lang="EN-US">NT</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">或</span><span lang="EN-US">2000</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，而且你已经设置过了</span><code><span lang="EN-US" style="FONT-FAMILY: 'Courier New'">DesktopProcess</span></code><span lang="EN-US"> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">注册表项，那么在你按</span><span lang="EN-US">F5</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">开始调试的时候，会有一个新的资源管理器窗口打开。只要你在那个窗口工作，以后重建</span><span lang="EN-US">DLL</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">时你将不会有问题，因为当你关掉窗口时，你的扩展也被卸载了。</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">在</span><span lang="EN-US">Windows 9x</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下，恐怕你不得不在调试之前关闭你的外壳。单击“开始”</span><span lang="EN-US">-></span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">“关闭系统”。按住</span><span lang="EN-US">Ctrl+Alt+Shift</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">然后点击“取消”。这将关闭资源管理器，然后你看见任务栏消失了。切换到</span><span lang="EN-US">MSVC</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">然后按</span><span lang="EN-US">F5</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">开始调试。按</span><span lang="EN-US">Shift+F5</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">关闭资源管理器停止调试。当你做完调试的时候，你可以运行</span><span lang="EN-US">Explorer</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">重新正常启动你的外壳。</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">它看起来是什么样的？</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下面是我们添加的项目看起来的样子：</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">这就是我们的菜单！</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下面是有敏感帮助时资源管理器的状态栏的样子：</span>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">而下面是消息框的样子，它显示了被选中的文件的文件名：</span>
<span lang="EN-US"><span style="mso-tab-count: 1">      </span></span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">本例程代码下载地址</span><span lang="EN-US">(11K)</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">：</span><span lang="EN-US">http://www.codeproject.com/shell/ShellExtGuide1/ShellExtGuide1_demo.zip</span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">下一部分……</span></h2>
<p style="TEXT-INDENT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">接着的第二部分，一个新的上下文菜单扩展将会告诉你如何同时对多个文件进行操作。</span>
<p style="MARGIN-LEFT: 21pt"><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">你可以从下面的网址获得这个和其他文章的最新版本：</span><span lang="EN-US">http://home.inreach.com/mdunn/code/ </span>
<span lang="EN-US"> <o:p></o:p></span>
<h2><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">关于翻译：</span></h2>
<span lang="EN-US"><span style="mso-tab-count: 1">      </span></span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">这是我第一次翻译文章，文章来自著名的</span><span lang="EN-US">http://www.codeproject.com/</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，翻译之前我看了</span><span lang="EN-US">csdn</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的开发文档，发现还是空白，所以就像把它翻译了，也许有对它感兴趣的人。文章总共有</span><span lang="EN-US">9</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">个部分。我没有太多的时间，只翻译了第一部分，也许能起到抛砖引玉的作用，让那些对外壳扩展不了解的人入个门，入了门的多个参考。更多的文章大家可以从</span><span lang="EN-US"><a href="http://www.codeproject.com/shell/">http://www.codeproject.com/shell/</a> </span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">找到。例子代码，原文也可以从那儿找到。我的</span><span lang="EN-US">email</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">是</span><span lang="EN-US">mefish@163.net</span><span style="FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">，头一次翻译，做得不好，任何意见、建议、鲜花、掌声、石头、带酒的啤酒瓶都将受到热烈欢迎……</span></div>
